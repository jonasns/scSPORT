---
title: "240409_scSPOT_code_PART5"
output: html_notebook
---

#### Load required packages
```{r}
# load required packages
library(readxl)
library(cowplot)
library(CATALYST)
library(diffcyt)
library(ggplot2) 
library(flowCore)
library(reshape)
library(ggrepel)
library(premessa)
library(flowCore)
library(plyr)
library(ggpubr)
library(dplyr)
library(stringr)
library(RColorBrewer)
library(ggrastr)
library(ggridges)
library(scran)
library(pheatmap)
library(viridis)
library(matrixStats)
library(scran)
library(rstatix)
```

```{r}
sessionInfo()
```

#### re-load the recombined sce
```{r}
sce_recombined = readRDS("~/Desktop/231102_sce_recombined_scSPORT_summary.rds")
```

#### Define the seed for the entire workflow
```{r}
#set.seed for the whole workflow, use my_seed from now on
my_seed <- 1234
set.seed(my_seed)
```

#### cluster_id needs to be present for filterSCE (even though it's not used)
```{r}
sce_recombined$cluster_id = 1
```


# Generate graphs that recapitulates division peaks per donor

```{r}
# selecting conditions to use
sce_use = sce_recombined
moi = "CFSE"

donor_list = rownames(table(sce_use$patient_id))

# start of loops
for(i in c(1:length(donor_list))) {
  donor = donor_list[i]
  nam = paste0("p",i) 


sce_temp1 = filterSCE(sce_use, subsets %in% c("CD8_CM", "CD8_EM", "Th1", "CD4_CM", "eTreg") & patient_id == donor & condition %in% c("stim_0x_Treg", "stim_10x_eTreg", "stim_10x_nTreg", "stim_10x_Tfr", "unstim_0x_Treg"))
test1  = as.data.frame(t(sce_temp1@assays@data$exprs))

test1 = test1[[moi]]
test1 = melt(test1)
test1$culture_condition = 1

test.table = rbind(test1)

names(test.table)[2] <- "culture_condition"
test.table$culture_condition=as.factor(test.table$culture_condition)

#plotting
p = ggplot(test.table, aes(x = value, y = culture_condition, group = culture_condition)) + 
  geom_density_ridges(fill = "#00AFBB") +
  ylab("% of max") +
  xlab(paste(moi, " expression")) +
  theme_bw(base_size = 14) +
  ggtitle(paste(moi, donor, sep = "_"))

assign(nam, p)

}

pp_list2 = list()
for(i in c(1:length(donor_list))) {
  pp_list2[i] = list(get(paste0("p",i)))

}
print(Sys.time())
```

#### special for Donor 9, since CD8s did not divide much
```{r}
# selecting conditions to use
sce_use = sce_recombined
moi = "CFSE"
i = 9
donor = donor_list[i]
nam = paste0("p",i) 

sce_temp1 = filterSCE(sce_use, subsets %in% c("Th1", "CD4_CM", "eTreg", "B_plasma", "B_act", "Th17") & patient_id == donor & condition %in% c("stim_0x_Treg"))
test1  = as.data.frame(t(sce_temp1@assays@data$exprs))

test1 = test1[[moi]]
test1 = melt(test1)
test1$culture_condition = 1

test.table = rbind(test1)

names(test.table)[2] <- "culture_condition"
test.table$culture_condition=as.factor(test.table$culture_condition)

#plotting
p = ggplot(test.table, aes(x = value, y = culture_condition, group = culture_condition)) + 
  geom_density_ridges(fill = "#00AFBB") +
  ylab("% of max") +
  xlab(paste(moi, " expression")) +
  theme_bw(base_size = 14) +
  ggtitle(paste(moi, donor, sep = "_"))

assign(nam, p)

pp_list2[2] = list(get(paste0("p",2)))
```


# Find the approximate location of first peak
```{r}
# Create an empty list to store objects
sce_list <- list()
```

```{r}
bd = 4.1 #begin dip
dn = 7 # donor number

# subset to donor
donor = donor_list[dn]
sce_temp1 = filterSCE(sce_recombined, patient_id == donor)

plot.data <-ggplot_build(pp_list2[[dn]])
plot.data <- as.data.frame(plot.data$data)
plot.data2 <- plot.data[plot.data$x > bd-0.2 & plot.data$x < bd+0.2,]; intersect1 = plot.data2$x[plot.data2$density==min(plot.data2$density)]
plot.data2 <- plot.data[plot.data$x > bd-1.2 & plot.data$x < bd-0.8,]; intersect2 = plot.data2$x[plot.data2$density==min(plot.data2$density)]
plot.data2 <- plot.data[plot.data$x > bd-2.2 & plot.data$x < bd-1.8,]; intersect3 = plot.data2$x[plot.data2$density==min(plot.data2$density)]
plot.data2 <- plot.data[plot.data$x > 0.0 & plot.data$x < bd-0.8,]; intersect4 = plot.data2$x[plot.data2$density==min(plot.data2$density)]

pp_list2[[dn]] + geom_vline(xintercept=c(intersect1,intersect2, intersect3))

ave_ints = ((intersect1 - intersect2) + (intersect2 - intersect3))/2
ave_ints

pp_list2[[dn]] + geom_vline(xintercept=c(intersect1+ ave_ints, intersect1,intersect1-1*ave_ints, intersect1-2*ave_ints,intersect1-3*ave_ints, intersect1-4*ave_ints))

# Calculate the differences for all conditions
differences <- intersect1+ave_ints - c(0, 1, 2, 3, 4) * ave_ints

differences[1] = differences[1]+3

# Sort the differences in non-decreasing order
sorted_differences <- sort(differences)

# Find the interval indices
div_levels <- findInterval(
  sce_temp1@assays@data$exprs["CFSE", ],
  sorted_differences,
  rightmost.closed = TRUE
)

# Calculate the maximum division level
max_div_level <- length(sorted_differences)

# Convert division levels to start at "div0"
converted_div_levels <- max_div_level - div_levels

# Adjust the division levels to match the desired range ("div0" to "div4")
adjusted_div_levels <- converted_div_levels -1

# Assign the adjusted division levels based on the comparisons
sce_temp1$div <- paste0("div", adjusted_div_levels)


color_intervals <- differences
color_intervals[1] = color_intervals[1] +1
color_intervals[6] = -1
line_intervals = color_intervals[2:5]

soi = "CD8_CM"
sce_use = filterSCE(sce_temp1, condition == "stim_0x_Treg" & subsets == soi)

new_tab = data.frame(exprs = sce_use@assays@data$exprs["CFSE",], div = sce_use$div, sample_id = sce_use$sample_id, condition = sce_use$condition, patient_id = sce_use$patient_id, subsets = sce_use$subsets)
new_tab = melt(new_tab)

p = ggplot(new_tab, aes(x = value, y = subsets)) + 
  geom_density_ridges(aes(x = value, y = subsets)) +
  theme_bw(base_size = 14) +
  theme_ridges()

plot.data <-ggplot_build(p)

new_tab2 = data.frame(x = plot.data$data[[1]]$x, density = plot.data$data[[1]]$density)

ggplot(new_tab2, aes(x = x, y = density)) + 
  geom_area(aes(fill = cut(x, breaks = color_intervals)), color = "black") +
  scale_fill_manual(values=rev(viridis(5))) +
  geom_vline(xintercept = line_intervals, color = "black", linetype = "dashed") +
  theme_bw(base_size = 14) +
  theme(legend.position = "none") +
  ggtitle(paste0(donor,"_",soi))

# Use dynamic names to store objects in the list
sce_list[[paste0("sce_d", dn)]] <- sce_temp1
```


```{r}
CFSE_function <- function(dn, bd) {
  library(viridis)
# subset to donor
donor = donor_list[dn]
sce_temp1 = filterSCE(sce_recombined, patient_id == donor)

# use pp_list2, which was generated in previous chunk
plot.data <-ggplot_build(pp_list2[[dn]])
plot.data <- as.data.frame(plot.data$data)
plot.data2 <- plot.data[plot.data$x > bd-0.2 & plot.data$x < bd+0.2,]; intersect1 = plot.data2$x[plot.data2$density==min(plot.data2$density)]
plot.data2 <- plot.data[plot.data$x > bd-1.2 & plot.data$x < bd-0.8,]; intersect2 = plot.data2$x[plot.data2$density==min(plot.data2$density)]
plot.data2 <- plot.data[plot.data$x > bd-2.2 & plot.data$x < bd-1.8,]; intersect3 = plot.data2$x[plot.data2$density==min(plot.data2$density)]
plot.data2 <- plot.data[plot.data$x > 0.0 & plot.data$x < bd-0.8,]; intersect4 = plot.data2$x[plot.data2$density==min(plot.data2$density)]

pp_list2[[dn]] + geom_vline(xintercept=c(intersect1,intersect2, intersect3, intersect4))

ave_ints = ((intersect1 - intersect2) + (intersect2 - intersect3))/2
ave_ints

pp_list2[[dn]] + geom_vline(xintercept=c(intersect1+ ave_ints, intersect1,intersect1-1*ave_ints, intersect1-2*ave_ints,intersect1-3*ave_ints, intersect1-4*ave_ints))

# Calculate the differences for all conditions
differences <- intersect1+ave_ints - c(0, 1, 2, 3, 4) * ave_ints

differences[1] = differences[1]+3

# Sort the differences in non-decreasing order
sorted_differences <- sort(differences)

# Find the interval indices
div_levels <- findInterval(
  sce_temp1@assays@data$exprs["CFSE", ],
  sorted_differences,
  rightmost.closed = TRUE
)

# Calculate the maximum division level
max_div_level <- length(sorted_differences)

# Convert division levels to start at "div0"
converted_div_levels <- max_div_level - div_levels

# Adjust the division levels to match the desired range ("div0" to "div4")
adjusted_div_levels <- converted_div_levels -1

# Assign the adjusted division levels based on the comparisons
sce_temp1$div <- paste0("div", adjusted_div_levels)

result_list <- list(sce_temp1 = sce_temp1)

color_intervals <- differences
color_intervals[1] = color_intervals[1] +1
color_intervals[6] = -1
line_intervals = color_intervals[2:5]

# loop to make graphs for each subset 
soi_list = rownames(table(sce_recombined$subsets))
pp_list = list()
ppp_list = list()

for(j in c(1:length(soi_list))) {
  soi = soi_list[j]
  nam = paste0("p",j)
  nam2 = paste0("pp",j)

if (table(sce_temp1$condition %in% c("stim_0x_Treg", "stim_10x_eTreg", "stim_10x_nTreg", "stim_10x_Tfr") & sce_temp1$subsets == soi)[2] >1| length(table(sce_temp1$condition %in% c("stim_0x_Treg", "stim_10x_eTreg", "stim_10x_nTreg", "stim_10x_Tfr") & sce_temp1$subsets == soi)) == 1) {
    sce_use = filterSCE(sce_temp1, condition %in% c("stim_0x_Treg", "stim_10x_eTreg", "stim_10x_nTreg", "stim_10x_Tfr") & subsets == soi)
    } else {
  sce_use = sce_temp1
}

new_tab = data.frame(exprs = sce_use@assays@data$exprs["CFSE",], div = sce_use$div, sample_id = sce_use$sample_id, condition = sce_use$condition, patient_id = sce_use$patient_id, subsets = sce_use$subsets)
new_tab = melt(new_tab)

p = ggplot(new_tab, aes(x = value, y = subsets)) + 
  geom_density_ridges(aes(x = value, y = subsets)) +
  theme_bw(base_size = 14) +
  theme_ridges()

plot.data <-ggplot_build(p)

new_tab2 = data.frame(x = plot.data$data[[1]]$x, density = plot.data$data[[1]]$density)

pp = ggplot(new_tab2, aes(x = x, y = density)) + 
  geom_area(aes(fill = cut(x, breaks = color_intervals)), color = "black") +
  scale_fill_manual(values=rev(viridis(5))) +
  geom_vline(xintercept = line_intervals, color = "black", linetype = "dashed") +
  theme_bw(base_size = 14) +
  theme(legend.position = "none", plot.title = element_text(size = 8)) +
  labs(x= "expression (asinh)", y = "density") +
  ggtitle(paste0(donor,"_",soi))

ppp = ggplot(new_tab,
        aes(y = value, x = div)) +
        geom_violin(aes(fill =div), width = 1, alpha = 1, color = "black") +
        stat_summary(fun.y=median, geom="point", shape=20, size=3, color="black", fill="black") +
        scale_fill_manual(values=viridis(5)) +
        theme_bw(base_size = 14) +
        theme(legend.position = "none", plot.title = element_text(size = 8), axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
        ggtitle(paste0(donor,"_",soi)) +
        labs(y= "expression (asinh)", x = "")

assign(nam, pp)
assign(nam2, ppp)

nam3 = paste0("ppp",j)

ppp = plotScatter(sce_use, c("Nd144Di", "Dy164Di"), assay = "exprs", label = "both", bins = 80) + ggtitle(paste0(donor,"_",soi)) + geom_vline(xintercept = line_intervals, color = "black", linetype = "dashed")

assign(nam3, ppp)

}

for(j in c(1:length(soi_list))) {
result_list[length(result_list)+1] = list(get(paste0("p",j)))
result_list[length(result_list)+1] =  list(get(paste0("pp",j)))
result_list[length(result_list)+1] =  list(get(paste0("ppp",j)))

}

  return(result_list)
}
```


```{r, fig.width=10, fig.height=6}
#these are the values determined per donor from previous code:
# d1 = 4.8, d2 = 4.5, d3 = 4.5, d4 = 4.5, d5 = 4.5, d6 = 4.5, d7 = 4.1, d8 = 4, d9 = 4.5, d10 = 4.8, d11 = 4.5, d12 = 4.8, d13 = 4.8, d14 = 4.8, d15 = 4.8

sce_d1_results = CFSE_function(1,4.8)
sce_d2_results = CFSE_function(2,4.5)
sce_d3_results = CFSE_function(3,4.5)
sce_d4_results = CFSE_function(4,4.5)
sce_d5_results = CFSE_function(5,4.5)
sce_d6_results = CFSE_function(6,4.5)
sce_d7_results = CFSE_function(7,4.1)
sce_d8_results = CFSE_function(8,4.0)
sce_d9_results = CFSE_function(9,4.5)
sce_d10_results = CFSE_function(10,4.8)
sce_d11_results = CFSE_function(11,4.5)
sce_d12_results = CFSE_function(12,4.8)
sce_d13_results = CFSE_function(13,4.8)
sce_d14_results = CFSE_function(14,4.8)
sce_d15_results = CFSE_function(15,4.8)

sce_d1 = sce_d1_results$sce_temp1
sce_d2 = sce_d2_results$sce_temp1
sce_d3 = sce_d3_results$sce_temp1
sce_d4 = sce_d4_results$sce_temp1
sce_d5 = sce_d5_results$sce_temp1
sce_d6 = sce_d6_results$sce_temp1
sce_d7 = sce_d7_results$sce_temp1
sce_d8 = sce_d8_results$sce_temp1
sce_d9 = sce_d9_results$sce_temp1
sce_d10 = sce_d10_results$sce_temp1
sce_d11 = sce_d11_results$sce_temp1
sce_d12 = sce_d12_results$sce_temp1
sce_d13 = sce_d13_results$sce_temp1
sce_d14 = sce_d14_results$sce_temp1
sce_d15 = sce_d15_results$sce_temp1
```

## 240314 - example graph from each donor
```{r}
pdf(paste0("~/Desktop/240314_draft_figures/CFSE_graphs/240314_CFSE_peaks_CD8_EM_all_donors.pdf"),width=8,height=5,paper='special') 
plot_grid(sce_d1_results[[23]], sce_d2_results[[23]], sce_d3_results[[23]], sce_d4_results[[23]], sce_d5_results[[23]], sce_d6_results[[23]], sce_d7_results[[23]], sce_d8_results[[23]], sce_d9_results[[23]], sce_d10_results[[23]], sce_d11_results[[23]], sce_d12_results[[23]], sce_d13_results[[23]], sce_d14_results[[23]], sce_d15_results[[23]])
dev.off()
```

```{r}
## remerge the sce's
sce_recombined = cbind(sce_d1,sce_d2,sce_d3,sce_d4,sce_d5,sce_d6,sce_d7,sce_d8,sce_d9,sce_d10,sce_d11,sce_d12,sce_d13,sce_d14,sce_d15, deparse.level=1)
sce_recombined$cluster_id = 1
```

## heatmap for Fig 1
First thing is to calculate % proliferated for all samples and subsets
```{r}
sce_sub = filterSCE(sce_recombined, condition %in% c("stim_10x_eTreg","stim_0x_Treg"))
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]

    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div0") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  
    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}
```

```{r}
## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)
```

```{r}
# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id

result_table_only_numbers_1 = result_table_only_numbers[grepl("0x_Treg", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("10x_eTreg", rownames(result_table_only_numbers)), ]

result_table_only_numbers_mean_1 =colMeans(as.matrix(result_table_only_numbers_1), na.rm = TRUE)
result_table_only_numbers_mean_2 =colMeans(as.matrix(result_table_only_numbers_2), na.rm = TRUE)

result_table_only_numbers_mean = rbind(result_table_only_numbers_mean_1,result_table_only_numbers_mean_2)
rownames(result_table_only_numbers_mean) = c("no Treg", "excess eTreg")
colnames(result_table_only_numbers_mean) = colnames(result_table_only_numbers)
```


### Calculate difference on a per donor level
```{r}
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("0x_Treg", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("10x_eTreg", rownames(result_table_only_numbers)), ]

rownames(result_table_only_numbers_1)
rownames(result_table_only_numbers_2)

result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2
```

```{r}
ph = pheatmap(result_table_delta, 
         border_color = "black", 
         cluster_rows = F,
         cluster_cols = F,
         color = cividis(30)
         )
```
```{r}
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)
```

```{r}
ph = pheatmap(result_table_delta_mean, 
         border_color = "black", 
         cluster_rows = F,
         cluster_cols = F,
         color = cividis(30)
         )
```

```{r}
colnames(result_table_delta_mean) = "div0"
```

```{r}
result_table_delta_mean_all = result_table_delta_mean
```

## do the same for the other divisions, to dissect where the Tregs block prolif
```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div1") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id



## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("0x_Treg", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("10x_eTreg", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div1"

# add to total dataset
result_table_delta_mean_all$div1 = result_table_delta_mean
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div2") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id



## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("0x_Treg", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("10x_eTreg", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div2"

# add to total dataset
result_table_delta_mean_all$div2 = result_table_delta_mean
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div3") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id



## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("0x_Treg", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("10x_eTreg", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div3"

# add to total dataset
result_table_delta_mean_all$div3 = result_table_delta_mean
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div4") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id



## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("0x_Treg", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("10x_eTreg", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div4"

# add to total dataset
result_table_delta_mean_all$div4 = result_table_delta_mean
```

```{r}
test = result_table_delta_mean_all[c(1:18),]
 
paletteLength <- 100
myColor <- colorRampPalette(c("darkred", "white", "darkblue"))(paletteLength)


# use floor and ceiling to deal with even/odd length pallette lengths
myBreaks <- c(seq(min(test), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(test)/paletteLength, max(test), length.out=floor(paletteLength/2)))

ph = pheatmap(test, 
         border_color = "black", 
         cluster_rows = T,
         cluster_cols = F,
         color = myColor,
         breaks=myBreaks
         )
```

```{r}
pdf(paste0("~/Desktop/231218_draft_figures/231218_Fig1_heat.pdf"),width=3,height=3,paper='special') 
ph
dev.off()
```

## 240327 - make heatmap (one line) of percentage divided to add to above heatmap
```{r}
sce_sub = filterSCE(sce_recombined, condition %in% c("stim_10x_eTreg","stim_0x_Treg"))
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div0") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  
    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id

## split into the two conditions
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("0x_Treg", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("10x_eTreg", rownames(result_table_only_numbers)), ]

# find mean values
result_table_only_numbers_1_mean =colMeans(as.matrix(result_table_only_numbers_1), na.rm = TRUE)
result_table_only_numbers_1_mean = as.data.frame(result_table_only_numbers_1_mean)

result_table_only_numbers_2_mean =colMeans(as.matrix(result_table_only_numbers_2), na.rm = TRUE)
result_table_only_numbers_2_mean = as.data.frame(result_table_only_numbers_2_mean)

# label the dataset
colnames(result_table_only_numbers_1_mean) = "div1" # this is "0x_Treg", but label as div1, to make heatmap same size
colnames(result_table_only_numbers_2_mean) = "div4" # this is "10x_eTreg", but label as div4, to make heatmap same size

# combine
result_table_percDivided_mean = result_table_only_numbers_1_mean
result_table_percDivided_mean$div4 = result_table_only_numbers_2_mean

## find delta values
result_table_delta = result_table_only_numbers_2 - result_table_only_numbers_1

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)
colnames(result_table_delta_mean) = "div1"
rownames(result_table_delta_mean) = colnames(result_table_delta)
result_table_delta_mean$div4 = result_table_delta_mean
```

```{r}
test = result_table_percDivided_mean[c(1:18),]
test <- test[row_order, ]
 
paletteLength <- 100
myColor <- magma(paletteLength)

# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(min(test), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(test)/paletteLength, max(test), length.out=floor(paletteLength/2)))

ph = pheatmap(test, 
         border_color = "black", 
         cluster_rows = F,
         cluster_cols = F,
         color = myColor#,
         #breaks=myBreaks
         )
```

```{r}
pdf(paste0("~/Desktop/240327_draft_figures/240328_Fig1_heat_percDiv.pdf"),width=1.78,height=3,paper='special') 
ph
dev.off()
```

```{r}
test = result_table_delta_mean[c(1:18),]
test <- test[row_order, ]

paletteLength <- 100
myColor <- colorRampPalette(c("darkgreen", "white", "gold"))(paletteLength)

# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(min(test), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(test)/paletteLength, max(test), length.out=floor(paletteLength/2)))

ph = pheatmap(test, 
         border_color = "black", 
         cluster_rows = F,
         cluster_cols = F,
         color = myColor,
         breaks=myBreaks
         )
```

```{r}
pdf(paste0("~/Desktop/240327_draft_figures/240329_Fig1_percDiv_difference.pdf"),width=1.87,height=3,paper='special') 
ph
dev.off()
```

## 240327 - make heatmap (one line) of division index to add to above heatmap
https://docs.flowjo.com/flowjo/experiment-based-platforms/proliferation/
Division Index is the average number of cell divisions that a cell in the original population has undergone. This is an average even for cells which never divided (i.e., includes the undivided peak).
As an example of how Proliferation Index and Division Index would be calculated, consider the following:

G0 = 15888

G1 = 32922

G2 = 13647

G3 = 897

Total Number of Cells: 15888 + 32922 +13647 +897 = 63354

Total Number of Divided Cells: 32922 +13647 +897 = 47466


-----need these two----
The number of cells at start of culture: 15888 + (32922/2) + (13647/4) + (897/8) = 35872.875

The total number of divisions: (32922/2)*1 + (13647/4)*2 + (897/8)*3 = 23620.875
-----need these two----


The number of cells that went into division: 35872.875 – 15888 = 19984.875

Division Index: 23620.875 / 35872.875 = 0.66

Proliferation Index: 23620.875 / 19984.875 = 1.18

Division Index: Total Number of Divisions / The number of cells at start of culture

Proliferation Index: Total Number of Divisions / Cells that went into division

So first I need the number of cells in each division. I should be able to get that simply from a table of my "div"

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    count <- sum(subset_data$div == "div0")
} else {
  count = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- count
  }
}

result_table_div0 = result_table


result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    count <- sum(subset_data$div == "div1")
} else {
  count = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- count
  }
}

result_table_div1 = result_table



result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    count <- sum(subset_data$div == "div2")
} else {
  count = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- count
  }
}

result_table_div2 = result_table


result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    count <- sum(subset_data$div == "div3")
} else {
  count = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- count
  }
}

result_table_div3 = result_table


result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    count <- sum(subset_data$div == "div4")
} else {
  count = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- count
  }
}

result_table_div4 = result_table


#The number of cells at start of culture: 
result_table_starting_cells = result_table_div0 + (result_table_div1/2) + (result_table_div2/4) + (result_table_div3/8) + (result_table_div4/16)

#The total number of divisions: 
result_table_tot_divisions = (result_table_div1/2)*1 + (result_table_div2/4)*2 + (result_table_div3/8)*3 + (result_table_div4/16)*4

# Division Index: Total Number of Divisions / The number of cells at start of culture
divIndex = result_table_tot_divisions/result_table_starting_cells

# rename and use previous code
result_table = divIndex

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id

## split into the two conditions
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("0x_Treg", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("10x_eTreg", rownames(result_table_only_numbers)), ]

# find mean values
result_table_only_numbers_1_mean =colMeans(as.matrix(result_table_only_numbers_1), na.rm = TRUE)
result_table_only_numbers_1_mean = as.data.frame(result_table_only_numbers_1_mean)

result_table_only_numbers_2_mean =colMeans(as.matrix(result_table_only_numbers_2), na.rm = TRUE)
result_table_only_numbers_2_mean = as.data.frame(result_table_only_numbers_2_mean)


# label the dataset
colnames(result_table_only_numbers_1_mean) = "div1" # this is "0x_Treg", but label as div1, to make heatmap same size
colnames(result_table_only_numbers_2_mean) = "div4" # this is "10x_eTreg", but label as div4, to make heatmap same size

# combine
result_table_divIndex_mean = result_table_only_numbers_1_mean
result_table_divIndex_mean$div4 = result_table_only_numbers_2_mean


## find delta values
result_table_delta = result_table_only_numbers_2 - result_table_only_numbers_1

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)
colnames(result_table_delta_mean) = "div1"
rownames(result_table_delta_mean) = colnames(result_table_delta)
result_table_delta_mean$div4 = result_table_delta_mean
```

```{r}
test = result_table_divIndex_mean[c(1:18),]
test <- test[row_order, ]
 
paletteLength <- 100
myColor <- viridis(paletteLength)

# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(min(test), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(test)/paletteLength, max(test), length.out=floor(paletteLength/2)))

ph = pheatmap(test, 
         border_color = "black", 
         cluster_rows = F,
         cluster_cols = F,
         color = myColor
         )
```

```{r}
pdf(paste0("~/Desktop/240327_draft_figures/240327_Fig1_divIndex.pdf"),width=1.8,height=3,paper='special') 
ph
dev.off()
```

```{r}
result_table_delta_mean_Fig1_divIndex = result_table_delta_mean # backup
test = result_table_delta_mean[c(1:18),]
test <- test[row_order, ]

paletteLength <- 100
myColor <- colorRampPalette(c("purple", "white", "darkblue"))(paletteLength)

# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(min(test), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(test)/paletteLength, max(test), length.out=floor(paletteLength/2)))

ph = pheatmap(test, 
         border_color = "black", 
         cluster_rows = F,
         cluster_cols = F,
         color = myColor,
         breaks=myBreaks
         )
```

```{r}
pdf(paste0("~/Desktop/240327_draft_figures/240329_Fig1_divIndex_difference.pdf"),width=1.9,height=3,paper='special') 
ph
dev.off()
```


# eTreg UMAPs

```{r}
sce_eTreg = filterSCE(sce_recombined, subsets == "eTreg" & condition == "stim_10x_eTreg")
```

```{r}
rowData(sce_eTreg)$marker_class = "state"
rowData(sce_eTreg[c("PD1","Ki67","CTLA4","CD45RA","CCR7","TCF1","CFSE","Helios","OGDH","XBP1","CD25", "CD98", "H3K27me3", "CPT1A", "CytC", "GLUT1", "CyclinB1", "VDAC1")])$marker_class = "type"
```

```{r}
set.seed(my_seed)
sce_eTreg <- runDR(sce_eTreg, 
             dr = "UMAP", 
             cells = 5000, 
             features = "type",
             n_neighbors = 10) 
set.seed(my_seed)
```

```{r, fig.height=3, fig.width=8}
plotDR(sce_eTreg, dr = "UMAP", color_by = "div" , facet_by = "div", ncol = 5) #+ 
  #scale_fill_manual(values=viridis(5)) +
  #scale_color_manual(values=viridis(5))
```

```{r, fig.height=3, fig.width=4}

p = plotDR(sce_eTreg, dr = "UMAP", color_by = "div") + 
  scale_fill_manual(values=viridis(5)) +
  scale_color_manual(values=viridis(5))

p$layers[[1]]$aes_params$size = 1

pp1 = ggplot(p$data, aes(x, y, colour = div, fill = div)) +
  geom_point_rast(aes(x, y, colour = div, fill = div), size =0.3, alpha = 0.8) +
  scale_fill_manual(values=viridis(5)) +
  scale_color_manual(values=viridis(5)) +
  theme_minimal(base_size = 14) + 
  labs(y="UMAP dim2",x = "UMAP dim1") + 
  guides(fill=guide_legend(title="division"), colour=guide_legend(title="division", override.aes = list(size=5)))

pp1
```


```{r}
pdf(paste0("~/Desktop/231218_draft_figures/eTreg_div_specific/231218_eTreg_div_UMAP.pdf"),width=3.5,height=2.5,paper='special') 
pp1
dev.off()
```

```{r, fig.height=3, fig.width=12}
#UMAP density plot. split by condition
p =　plotDR(sce_eTreg, dr = "UMAP", color_by = "div" , facet_by = "div", ncol = 5) + 
  scale_fill_manual(values=viridis(5)) +
  scale_color_manual(values=viridis(5))

p$layers[[1]]$aes_params$alpha = 0.02
p$layers[[1]]$aes_params$size = 2

pp1 = p + stat_density_2d(geom = "polygon", contour = TRUE,
                  aes(fill = after_stat(nlevel)), colour = "black",
                  bins = 8) +
  scale_fill_distiller(palette = "Spectral", direction = -1) +
  theme_classic()
pp1
```


```{r}
pdf(paste0("~/Desktop/231218_draft_figures/eTreg_div_specific/231218_eTreg_density_UMAP.pdf"),width=10,height=2.5,paper='special') 
pp1
dev.off()
```


## Differential expression between divisions 
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("stim_10x_eTreg"))

# remove channels that has more than one marker, or are too different in FC (confounding factors)
sce_oi <- sce_oi[-which(rownames(sce_oi) %in% c("CD21_CD3","CD45RO_Dead", "CFSE", "Ki67")), ]

#subset to only eTregs
sce_oi = sce_oi[,grep("eTreg",sce_oi$subsets)]
```


```{r}
# we need both the FC and the wilcoxon test FDR. So we run both wilcox and t and combine the results after.
markers <- findMarkers(sce_oi, groups = sce_oi$div, assay.type = "exprs", pval.type = "some", direction = "any", full.stats=TRUE, test.type = "wilcox", block = sce_oi$patient_id)
markers1 = markers$div1$stats.div0
markers2 = markers$div2$stats.div0
markers3 = markers$div3$stats.div0
markers4 = markers$div4$stats.div0

markers <- findMarkers(sce_oi, groups = sce_oi$div, assay.type = "exprs", pval.type = "some", direction = "any", full.stats=TRUE, test.type = "t", block = sce_oi$patient_id)
markers1_2 = markers$div1$stats.div0
markers2_2 = markers$div2$stats.div0
markers3_2 = markers$div3$stats.div0
markers4_2 = markers$div4$stats.div0

markers1 = merge(markers1, markers1_2, by = markers1, by.x = 0, by.y = 0)
markers2 = merge(markers2, markers2_2, by = markers2, by.x = 0, by.y = 0)
markers3 = merge(markers3, markers3_2, by = markers3, by.x = 0, by.y = 0)
markers4 = merge(markers4, markers4_2, by = markers4, by.x = 0, by.y = 0)
```

```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers4)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.5,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.5,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.5,2))
vp_name = subset(vp, logFC>log(1.6,2) & log.FDR.x<(-1.30) | logFC<(-log(1.3,2)) & log.FDR.x<(-1.30) | log.FDR.x<(-750))

vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[5],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[1],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("div0                                   div4") + geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-1.7,2.3)

pdf(paste0("~/Desktop/240226_draft_figures/eTreg_div_specific/240226_eTreg_div4_vs_div0_volcano_noCFSEKi67.pdf"),width=6,height=4,paper='special') 
vp_plot4 + xlim(-1.7,2.3)
dev.off()

```


```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers3)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.5,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.5,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.5,2))
vp_name = subset(vp, logFC>log(1.6,2) & log.FDR.x<(-1.30) | logFC<(-log(1.3,2)) & log.FDR.x<(-1.30) | log.FDR.x<(-300))

vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[4],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[1],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("div0                                   div3") + geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-1.7,2.3)

pdf(paste0("~/Desktop/240226_draft_figures/eTreg_div_specific/240226_eTreg_div3_vs_div0_volcano_noCFSEKi67.pdf"),width=6,height=4,paper='special') 
vp_plot4 + xlim(-1.7,2.3)
dev.off()
```


```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers2)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.5,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.5,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.5,2))
vp_name = subset(vp, logFC>log(1.6,2) & log.FDR.x<(-1.30) | logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | log.FDR.x<(-300))

vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[3],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[1],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("div0                                   div2") + geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-1.7,2.3)

pdf(paste0("~/Desktop/240226_draft_figures/eTreg_div_specific/240226_eTreg_div2_vs_div0_volcano_noCFSEKi67.pdf"),width=6,height=4,paper='special') 
vp_plot4 + xlim(-1.7,2.3)
dev.off()

```


```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers1)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.5,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.5,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.5,2))
vp_name = subset(vp, logFC>log(1.6,2) & log.FDR.x<(-1.30) | logFC<(-log(1.3,2)) & log.FDR.x<(-1.30) | log.FDR.x<(-300))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[2],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[1],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("div0                                   div1") + geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-1.7,2.3)

pdf(paste0("~/Desktop/240226_draft_figures/eTreg_div_specific/240206_eTreg_div1_vs_div0_volcano_noCFSEKi67.pdf"),width=6,height=4,paper='special') 
vp_plot4 + xlim(-1.7,2.3)
dev.off()

```

It is the same principle for other cell types, and I have excluded it not to be too repetitive in the code


## 240226 - number of Tregs in each division

```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("stim_10x_eTreg"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
df = table(sce_oi$subsets, sce_oi$sample_id, sce_oi$condition, sce_oi$patient_id, sce_oi$div)
df = as.data.frame(df)
```

```{r}
result <- df %>%
  filter(Var1 %in% c("eTreg")) %>%
  group_by(Var5, Var4) %>%
  summarise(
    eTreg_Freq = sum(Freq[Var1 == "eTreg"])
  ) %>%
  group_by(Var4) %>%
  mutate(
    total_eTreg_Freq = sum(eTreg_Freq),
    eTreg_Percentage = (eTreg_Freq / total_eTreg_Freq) * 100
  )

print(result)
```


```{r}
bluecols = brewer.pal(9,"Blues")[c(2,4,6,8,9)]

g = ggplot(data = result,
        aes(y = eTreg_Percentage, x = Var5)) +
        geom_boxplot(width = 0.8, guides = FALSE, outlier.size = 0, alpha = 1, color = "black") +# , fill = color_box) +
        geom_line(aes(group = Var4),alpha = 0.5) +
        geom_point(aes(fill = Var5), size = 2, alpha = 0.8, position = position_jitterdodge(), shape=21) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("% eTreg") +
    theme_bw(base_size = 14) +
    scale_fill_manual(values=bluecols) +
    scale_color_manual(values=bluecols)
  

g
```

```{r}
pdf(paste0("~/Desktop/240226_draft_figures/240226_percentage_eTreg_per_division.pdf"),width=4,height=2.5,paper='special') 
g
dev.off()
```


## 240214 - compare each division for neTreg versus eTreg
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("stim_10x_eTreg","stim_10x_nTreg"))
sce_oi = filterSCE(sce_oi, !(patient_id %in% c("T00_D1","T01_D1","T02_D1","T02_D2","T03_D1","T03_D3"))) #donors not used in the subset comparisons

# remove channels that has more than one marker
sce_oi <- sce_oi[-which(rownames(sce_oi) %in% c("CD21_CD3","CD45RO_Dead")), ]

#subset to only eTregs
sce_oi = sce_oi[,grep("eTreg",sce_oi$subsets)]
sce_oi$subsets = droplevels(sce_oi$subsets)

# make a new coldata column with condition and division merged
sce_oi$condition_div <- paste(sce_oi$condition, sce_oi$div, sep = "_")
sce_oi$condition_div = as.factor(sce_oi$condition_div)

table(sce_oi$sample_id, sce_oi$subsets)
```

```{r}
markers <- findMarkers(sce_oi, groups = sce_oi$condition_div, assay.type = "exprs", pval.type = "some", direction = "any", full.stats=TRUE, test.type = "wilcox", block = sce_oi$patient_id )

markers0 = markers$stim_10x_nTreg_div0$stats.stim_10x_eTreg_div0
markers1 = markers$stim_10x_nTreg_div1$stats.stim_10x_eTreg_div1
markers2 = markers$stim_10x_nTreg_div2$stats.stim_10x_eTreg_div2
markers3 = markers$stim_10x_nTreg_div3$stats.stim_10x_eTreg_div3
markers4 = markers$stim_10x_nTreg_div4$stats.stim_10x_eTreg_div4

markers <- findMarkers(sce_oi, groups = sce_oi$condition_div, assay.type = "exprs", pval.type = "some", direction = "any", full.stats=TRUE, test.type = "t",block = sce_oi$patient_id)
markers0_2 = markers$stim_10x_nTreg_div0$stats.stim_10x_eTreg_div0
markers1_2 = markers$stim_10x_nTreg_div1$stats.stim_10x_eTreg_div1
markers2_2 = markers$stim_10x_nTreg_div2$stats.stim_10x_eTreg_div2
markers3_2 = markers$stim_10x_nTreg_div3$stats.stim_10x_eTreg_div3
markers4_2 = markers$stim_10x_nTreg_div4$stats.stim_10x_eTreg_div4

markers0 = merge(markers0, markers0_2, by = markers0, by.x = 0, by.y = 0)
markers1 = merge(markers1, markers1_2, by = markers0, by.x = 0, by.y = 0)
markers2 = merge(markers2, markers2_2, by = markers0, by.x = 0, by.y = 0)
markers3 = merge(markers3, markers3_2, by = markers0, by.x = 0, by.y = 0)
markers4 = merge(markers4, markers4_2, by = markers0, by.x = 0, by.y = 0)
```

```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers4)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Reds")[9],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Blues")[9],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("original eTreg              nTreg-derived eTreg")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-2.2,2.1)

pdf(paste0("~/Desktop/240226_draft_figures/neTreg_div_specific/240226_neTreg_vs_eTreg_div4_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4  + xlim(-2.2,2.1)
dev.off()

```


```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers3)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Reds")[8],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Blues")[8],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("original eTreg              nTreg-derived eTreg")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-2.2,2.1)

pdf(paste0("~/Desktop/240226_draft_figures/neTreg_div_specific/240226_neTreg_vs_eTreg_div3_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4  + xlim(-2.2,2.1)
dev.off()

```


```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers2)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Reds")[6],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Blues")[6],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("original eTreg              nTreg-derived eTreg")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-2.2,2.1)

pdf(paste0("~/Desktop/240226_draft_figures/neTreg_div_specific/240226_neTreg_vs_eTreg_div2_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4  + xlim(-2.2,2.1)
dev.off()

```


```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers1)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Reds")[4],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Blues")[4],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("original eTreg              nTreg-derived eTreg")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-2.2,2.1)

pdf(paste0("~/Desktop/240226_draft_figures/neTreg_div_specific/240226_neTreg_vs_eTreg_div1_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4  + xlim(-2.2,2.1)
dev.off()

```


```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers0)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Reds")[2],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Blues")[2],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("original eTreg              nTreg-derived eTreg")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-2.2,2.1)

pdf(paste0("~/Desktop/240226_draft_figures/neTreg_div_specific/240226_neTreg_vs_eTreg_div0_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4  + xlim(-2.2,2.1)
dev.off()

```


##    Total CD8 T cells UMAPs
```{r}
sce_CD8 = filterSCE(sce_recombined, subsets %in% c("CD8_naive", "CD8_CM","CD8_EM","CD8_TEMRA") & condition %in% c("stim_0x_Treg","stim_10x_eTreg"))
```

```{r}
# remove channels that has more than one marker
sce_CD8 <- sce_CD8[-which(rownames(sce_CD8) %in% c("CD21_CD3","CD45RO_Dead")), ]
```

```{r}
rowData(sce_CD8)$marker_class = "state"
rowData(sce_CD8[c("CD45RA", "Ki67", "CD27", "CD38", "CFSE", "CCR7")])$marker_class = "type"
```

```{r}
set.seed(my_seed)
sce_CD8 <- runDR(sce_CD8, 
             dr = "UMAP", 
             cells = 5000, 
             features = "type",
             n_neighbors = 10) 
set.seed(my_seed)
```

```{r, fig.height=4, fig.width=6}
plotDR(sce_CD8, dr = "UMAP", color_by = "div")
```

```{r, fig.height=4, fig.width=18}
plot_grid(ncol = 3, plotDR(sce_CD8, dr = "UMAP", color_by = "patient_id"),
plotDR(sce_CD8, dr = "UMAP", color_by = "CD45RA"),
plotDR(sce_CD8, dr = "UMAP", color_by = "CCR7"))
```

```{r, fig.height=8, fig.width=16}
plotDR(sce_CD8, dr = "UMAP", color_by = type_markers(sce_CD8),ncol = 6)
```

```{r, fig.height=12, fig.width=16}
plotDR(sce_CD8, dr = "UMAP", color_by = state_markers(sce_CD8),ncol = 8)
```

```{r, fig.height=3, fig.width=8}
p = plotDR(sce_CD8, dr = "UMAP", color_by = "div") + 
  scale_fill_manual(values=viridis(5)) +
  scale_color_manual(values=viridis(5))

p$layers[[1]]$aes_params$size = 1

pp1 = ggplot(p$data, aes(x, y, colour = div, fill = div)) +
  geom_point_rast(aes(x, y, colour = div, fill = div), size =0.3, alpha = 0.8) +
  scale_fill_manual(values=viridis(5)) +
  scale_color_manual(values=viridis(5)) +
  theme_minimal(base_size = 14) + 
  labs(y="UMAP dim1",x = "UMAP dim2") + 
  guides(fill=guide_legend(title="division"), colour=guide_legend(title="division", override.aes = list(size=5)))


p2 = plotDR(sce_CD8, dr = "UMAP", color_by = "CFSE") 
p2$layers[[1]]$aes_params$size = 1

pp2 = ggplot(p2$data, aes(x, y, colour = value, fill = value)) +
  geom_point_rast(aes(x, y, colour = value, fill = value), size =0.3, alpha = 0.8) +
  theme_minimal(base_size = 14) + 
  scale_color_viridis(direction = 1) +
  labs(y="UMAP dim1",x = "UMAP dim2") + 
  guides(fill=guide_legend(title="CFSE"), colour=guide_legend(title="CFSE", override.aes = list(size=5)))

plot_grid(p,p2)

plot_grid(pp1,pp2)
```

```{r}
pdf(paste0("~/Desktop/231122_draft_figures/231109_CD8_EM_UMAP_divisions.pdf"),width=8,height=3,paper='special') 
plot_grid(pp1,pp2)
dev.off()
```


# 240401 - CD8-EM density UMAPs
```{r}
sce_CD8 = filterSCE(sce_recombined, subsets %in% c("CD8_EM") & condition %in% c("stim_0x_Treg","stim_10x_eTreg"))
sce_CD8 <- sce_CD8[-which(rownames(sce_CD8) %in% c("CD21_CD3","CD45RO_Dead")), ]
sce_CD8$cluster_id = 1
rowData(sce_CD8)$marker_class = "state"
rowData(sce_CD8[c("Ki67", "CD38", "GzmB", "CD98", "CXCR3")])$marker_class = "type"
```

```{r}
# rerun UMAP
set.seed(my_seed)
sce_CD8 <- runDR(sce_CD8, 
             dr = "UMAP", 
             cells = 5000, 
             features = "type",
             n_neighbors = 10) 
set.seed(my_seed)
```

```{r, fig.height=4, fig.width=6}
plotDR(sce_CD8, dr = "UMAP", color_by = "div")
```

```{r, fig.height=4, fig.width=6}
plotDR(sce_CD8, dr = "UMAP", color_by = "patient_id")
```

```{r, fig.height=8, fig.width=16}
plotDR(sce_CD8, dr = "UMAP", color_by = type_markers(sce_CD8),ncol = 6)
```

```{r, fig.height=12, fig.width=16}
plotDR(sce_CD8, dr = "UMAP", color_by = state_markers(sce_CD8),ncol = 8)
```


```{r, fig.height=3, fig.width=12}
#UMAP density plot. split by condition
p =　plotDR(sce_CD8, dr = "UMAP", color_by = "div" , facet_by = "div", ncol = 5) + 
  scale_fill_manual(values=viridis(5)) +
  scale_color_manual(values=viridis(5))

p$layers[[1]]$aes_params$alpha = 0.02
p$layers[[1]]$aes_params$size = 2

pp1 = p + stat_density_2d(geom = "polygon", contour = TRUE,
                  aes(fill = after_stat(nlevel)), colour = "black",
                  bins = 16,linewidth = 0.3) +
  scale_fill_distiller(palette = "Spectral", direction = -1) #+
  #theme_classic()
pp1
```

```{r}
pdf(paste0("~/Desktop/240401_draft_figures/240401_CD8_EM_UMAP_density_divisions.pdf"),width=12,height=3,paper='special') 
pp1
dev.off()
```

```{r, fig.height=3, fig.width=16}
p1 = plotDR(sce_CD8, dr = "UMAP", color_by = "CFSE") 
p1$layers[[1]]$aes_params$size = 1

pp1 = ggplot(p1$data, aes(x, y, colour = value, fill = value)) +
  geom_point_rast(aes(x, y, colour = value, fill = value), size =0.3, alpha = 0.8) +
  theme_minimal(base_size = 14) + 
  scale_color_viridis(option = "mako", direction = 1) +
  labs(y="UMAP dim2",x = "UMAP dim1") + 
  guides(fill=guide_legend(title="CFSE"), colour=guide_legend(title="CFSE", override.aes = list(size=5)))


p2 = plotDR(sce_CD8, dr = "UMAP", color_by = "div") + 
  scale_fill_manual(values=viridis(5)) +
  scale_color_manual(values=viridis(5))

p2$layers[[1]]$aes_params$size = 1

pp2 = ggplot(p2$data, aes(x, y, colour = div, fill = div)) +
  geom_point_rast(aes(x, y, colour = div, fill = div), size =0.3, alpha = 0.8) +
  scale_fill_manual(values=viridis(5)) +
  scale_color_manual(values=viridis(5)) +
  theme_minimal(base_size = 14) + 
  labs(y="UMAP dim2",x = "UMAP dim1") + 
  guides(fill=guide_legend(title="division"), colour=guide_legend(title="division", override.aes = list(size=5)))


p3 = plotDR(sce_CD8, dr = "UMAP", color_by = "Ki67") 
p3$layers[[1]]$aes_params$size = 1

pp3 = ggplot(p3$data, aes(x, y, colour = value, fill = value)) +
  geom_point_rast(aes(x, y, colour = value, fill = value), size =0.3, alpha = 0.8) +
  theme_minimal(base_size = 14) + 
  scale_color_viridis(option = "inferno", direction = 1) +
  labs(y="UMAP dim2",x = "UMAP dim1") + 
  guides(fill=guide_legend(title="Ki67"), colour=guide_legend(title="Ki67", override.aes = list(size=5)))


plot_grid(p1,p2,p3,ncol=3)

plot_grid(pp1,pp2,pp3,ncol=3)
```

```{r}
pdf(paste0("~/Desktop/240402_draft_figures/240402_CD8_EM_UMAP_CFSE_div_Ki67.pdf"),width=12,height=3,paper='special') 
plot_grid(pp1,pp2,pp3,ncol=3)
dev.off()
```

## 240401 - cell cycle analysis in CD8 divisions
```{r}
sce_oi = sce_CD8
sce_cc = filterSCE(sce_oi, subsets == "CD8_EM")
```

```{r}
#cell cycle division markers
plotPbExprs(sce_cc,fun = "mean", features = c("Ki67", "IdU", "CyclinB1"))
```

## gating Ki67-negative (G0) cells
```{r}
left <- 3.0
right <- 9
lower <- -0.01
upper <- 8
gate = annotate("rect",xmin = left, xmax = right, ymin = lower, ymax = upper, fill = NA, linetype = 1, color = 'red')

ps = plotScatter(sce_cc, c("Er168Di", "Cd112Di"), assay = "exprs", label = "both") + gate
ps
```

```{r}
pdf("~/Desktop/240401_draft_figures/240401_CD8EM_ki67_gating.pdf",width=2,height=2,paper='special') 
ps
dev.off()
```

#### add label to the cells
When happy with the gate above, can continue below, and add labels to the cells
```{r}
exMat = as.data.frame(t(sce_cc@assays@data$exprs))

cells <- exMat$Ki67 > left 

cells2 = as.character(cells)
cells3 = str_replace(cells2, "TRUE", "Ki67+")
cells4 = str_replace(cells3, "FALSE", "Ki67-")
cells4 = as.factor(cells4)

sce_cc$Ki67_gated = cells4
```

## split into G0 (Ki67-) and GX (Ki67+)
```{r}
sce_G0 = filterSCE(sce_cc, Ki67_gated == "Ki67-")

sce_GX = filterSCE(sce_cc, Ki67_gated == "Ki67+")
```

## make gates for G1, S, and G2/M based on IdU
```{r}
left <- 2.2
right <- 6.5
lower <- 2
upper <- 7

gate = annotate("rect",xmin = left, xmax = right, ymin = lower, ymax = upper, fill = NA, linetype = 1, color = 'red')

ps = plotScatter(sce_GX, c("Dy164Di", "I127Di"), assay = "exprs", label = "both") + gate
ps
```

```{r}
pdf("~/Desktop/240401_draft_figures/240401_CD8EM_IdU_gating.pdf",width=2,height=2,paper='special') 
ps
dev.off()
```

#### add label to the cells
When happy with the gate above, can continue below, and add labels to the cells
```{r}
exMat = as.data.frame(t(sce_GX@assays@data$exprs))

cells <- exMat$CyclinB1 < right & exMat$CyclinB1 > left & exMat$IdU > lower & exMat$IdU< upper

cells2 = as.character(cells)
cells3 = str_replace(cells2, "TRUE", "S")
cells4 = str_replace(cells3, "FALSE", "notS")
cells4 = as.factor(cells4)

sce_GX$S_gated = cells4
```

## split into G0 (Ki67-) and GX (Ki67+)
```{r}
sce_S = filterSCE(sce_GX, S_gated == "S")

sce_GX = filterSCE(sce_GX, S_gated == "notS")
```

```{r}
left <- 4.5
right <- 7.5
lower <- 0.01
upper <- 9

gate = annotate("rect",xmin = left, xmax = right, ymin = lower, ymax = upper, fill = NA, linetype = 1, color = 'red')

ps = plotScatter(sce_GX, c("Dy164Di", "Cd112Di"), assay = "exprs", label = "both") + gate
ps
```

```{r}
pdf("~/Desktop/240401_draft_figures/240401_CD8EM_CyclinB1_gating.pdf",width=2,height=2,paper='special') 
ps
dev.off()
```

#### add label to the cells
When happy with the gate above, can continue below, and add labels to the cells
```{r}
exMat = as.data.frame(t(sce_GX@assays@data$exprs))

cells <- exMat$CyclinB1 < right & exMat$CyclinB1 > left

cells2 = as.character(cells)
cells3 = str_replace(cells2, "TRUE", "G2")
cells4 = str_replace(cells3, "FALSE", "G1")
cells4 = as.factor(cells4)

sce_GX$G12_gated = cells4
```

## split into G1 and G2
```{r}
sce_G1 = filterSCE(sce_GX, G12_gated == "G1")

sce_G2 = filterSCE(sce_GX, G12_gated == "G2")
```

## combine to one sce
```{r}
colData(sce_G0) = colData(sce_G0)[c(1:6)]
colData(sce_G1) = colData(sce_G1)[c(1:6)]
colData(sce_G2) = colData(sce_G2)[c(1:6)]
colData(sce_S) = colData(sce_S)[c(1:6)]

sce_G0$cc = "G0"
sce_G1$cc = "G1"
sce_G2$cc = "G2"
sce_S$cc = "S"
```

```{r}
#then combine the dataset like this:
sce_recombined_cc = cbind(sce_G0,sce_G1,sce_G2,sce_S, deparse.level=1)
```

## plotting histograms
```{r, fig.width=16, fig.height=16}
# a couple of table processing steps
x = sce_recombined_cc

# get frequencies by cluster & sample
dn_list = levels(x$patient_id)

df_all <- data.frame()
ns_all <- data.frame()
for (i in c(1:length(dn_list))) {
  dn = dn_list[i]
  y = filterSCE(x, patient_id == dn, condition == "stim_10x_eTreg")
  ns <- table(
        cluster_id = y$cc, 
        division = y$div)
    
  
    fq <- prop.table(ns, "division") * 100
    df <- as.data.frame(fq)
    df$donor = dn
    df_all <- rbind(df_all, df)
    df2 <- as.data.frame(ns)
    df2$donor = dn
    ns_all <- rbind(ns_all, df2)
}
# subset to make individual graphs of each celltype
snames2 = c("G0","G1","S", "G2")
for(i in c(1:length(snames2))) {
df_sub = subset(df_all, df_all$cluster_id == snames2[i])

nam = paste0("df_list_",i) 
assign(nam, melt(df_sub))
}

df_list_list = list()
for(i in c(1:length(snames2))) {
  df_list_list[i] = list(get(paste0("df_list_",i)))
}


df_all <- data.frame()
ns_all <- data.frame()
for (i in c(1:length(dn_list))) {
  dn = dn_list[i]
  y = filterSCE(x, patient_id == dn, condition == "stim_0x_Treg")
  ns <- table(
        cluster_id = y$cc, 
        division = y$div)
    
  
    fq <- prop.table(ns, "division") * 100
    df <- as.data.frame(fq)
    df$donor = dn
    df_all <- rbind(df_all, df)
    df2 <- as.data.frame(ns)
    df2$donor = dn
    ns_all <- rbind(ns_all, df2)
}
# subset to make individual graphs of each celltype
snames2 = c("G0","G1","S", "G2")
for(i in c(1:length(snames2))) {
df_sub = subset(df_all, df_all$cluster_id == snames2[i])

nam = paste0("df_list2_",i) 
assign(nam, melt(df_sub))
}

df_list_list2 = list()
for(i in c(1:length(snames2))) {
  df_list_list2[i] = list(get(paste0("df_list2_",i)))
}


# Add condition column 
for (i in 1:length(df_list_list)) {
  df_list_list[[i]]$condition <- "stim_10x_eTreg"
}

# Add condition column 
for (i in 1:length(df_list_list2)) {
  df_list_list2[[i]]$condition <- "stim_0x_Treg"
}

combined_df_list <- list()

for (i in 1:length(df_list_list)) {
  combined_df_list[[i]] <- rbind(df_list_list[[i]], df_list_list2[[i]])
}


# colour definition
col_order = c(brewer.pal(9,"Greens")[6], brewer.pal(9,"Blues")[6])

my_comparisons = list(c("stim_0x_Treg", "stim_10x_eTreg"))

# plotting 
for(i in c(1:length(snames2))) {
  nam = paste0("g",i) 
  g = ggplot(data = combined_df_list[[i]],
        aes(y = value, x = division, fill = condition)) +
        geom_boxplot(width = 0.7, outlier.size = 0, alpha = 1, position = position_dodge(width = 0.8)) +# , fill = color_box) +
        geom_point(size = 1, alpha = 0.6,shape=21, position = position_dodge(width = 0.8)) +
        scale_y_continuous(limits = c(0, max(df_list_list[[i]]$value))) +
        theme_bw() +
        labs(y= paste("%", snames2[i]), x = "") +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
        theme(legend.position="none") +
        scale_fill_manual(values = col_order) +
        scale_color_manual(values = col_order)
        
  assign(nam, g)
}

#put all plots into a list
g_list = list()
for(i in c(1:length(snames2))) {
  g_list[i] = list(get(paste0("g",i)))
}

# plot every graph that was added to the list
gridExtra::grid.arrange(grobs = g_list)
```

```{r}
#print pdf
pdf("~/Desktop/240402_draft_figures/240403_CD8-EM_cell_cycle_breakdown_on_divisions_overlay.pdf",width=12,height=3,paper='special') 
gridExtra::grid.arrange(grobs = g_list, ncol = 4)
dev.off()
```

## stats on cell cycle
first test for normality:
```{r}
combined_df_list[[1]] %>%
  group_by(condition, division) %>%
  shapiro_test(value)
```

```{r}
combined_df_list[[2]] %>%
  group_by(condition, division) %>%
  shapiro_test(value)
```

```{r}
combined_df_list[[3]] %>%
  group_by(condition, division) %>%
  shapiro_test(value)
```

```{r}
combined_df_list[[4]] %>%
  group_by(condition, division) %>%
  shapiro_test(value)
```

Some are normal distributed, but most are not. So we do a wilcox test

```{r}
df = combined_df_list[[1]]

#sort the table by donor and condition column. NOTE! this is important for the pairing. 
df <- df[order(df$donor, df$condition), ]

# pairwise comparisons
pwc <- df %>%
  group_by(division) %>%
  wilcox_test(value ~ condition, paired = TRUE, p.adjust.method = "bonferroni")
pwc
```

```{r}
df = combined_df_list[[2]]

#sort the table by donor and condition column. NOTE! this is important for the pairing. 
df <- df[order(df$donor, df$condition), ]

# pairwise comparisons
pwc <- df %>%
  group_by(division) %>%
  wilcox_test(value ~ condition, paired = TRUE, p.adjust.method = "bonferroni")
pwc
```

```{r}
df = combined_df_list[[3]]

#sort the table by donor and condition column. NOTE! this is important for the pairing. 
df <- df[order(df$donor, df$condition), ]

# pairwise comparisons
pwc <- df %>%
  group_by(division) %>%
  wilcox_test(value ~ condition, paired = TRUE, p.adjust.method = "bonferroni")
pwc
```

```{r}
df = combined_df_list[[4]]

#sort the table by donor and condition column. NOTE! this is important for the pairing. 
df <- df[order(df$donor, df$condition), ]

# pairwise comparisons
pwc <- df %>%
  group_by(division) %>%
  wilcox_test(value ~ condition, paired = TRUE, p.adjust.method = "bonferroni")
pwc
```


## CD8-EM findmarkers without Tregs present
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("stim_0x_Treg"))
table(sce_oi$condition, sce_oi$patient_id)

# remove channels that has more than one marker
sce_oi <- sce_oi[-which(rownames(sce_oi) %in% c("CD21_CD3","CD45RO_Dead")), ]

#subset to only CD8_EM
sce_oi = sce_oi[,grep("CD8_EM",sce_oi$subsets)]
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
markers <- findMarkers(sce_oi, groups = sce_oi$div, assay.type = "exprs", pval.type = "some", direction = "any", full.stats=TRUE, test.type = "wilcox", block = sce_oi$patient_id)
markers1 = markers$div1$stats.div0
markers2 = markers$div2$stats.div0
markers3 = markers$div3$stats.div0
markers4 = markers$div4$stats.div0


markers <- findMarkers(sce_oi, groups = sce_oi$div, assay.type = "exprs", pval.type = "some", direction = "any", full.stats=TRUE, test.type = "t", block = sce_oi$patient_id)
markers1_2 = markers$div1$stats.div0
markers2_2 = markers$div2$stats.div0
markers3_2 = markers$div3$stats.div0
markers4_2 = markers$div4$stats.div0

markers1 = merge(markers1, markers1_2, by = markers1, by.x = 0, by.y = 0)
markers2 = merge(markers2, markers2_2, by = markers2, by.x = 0, by.y = 0)
markers3 = merge(markers3, markers3_2, by = markers3, by.x = 0, by.y = 0)
markers4 = merge(markers4, markers4_2, by = markers4, by.x = 0, by.y = 0)
```


```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers1)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

#remove CFSE and Ki67, as they are much more significant than others
vp <- vp[!(vp$Row.names %in% c("CFSE", "Ki67")), ]

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[2],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[1],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("div0                                       div1")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-1.5,3.1)


pdf(paste0("~/Desktop/231222_draft_figures/CD8_EM_div_specific/231222_CD8_EM_div0_vs_div1_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-1.5,3.1)
dev.off()

```




```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers2)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

#remove CFSE and Ki67, as they are much more significant than others
vp <- vp[!(vp$Row.names %in% c("CFSE", "Ki67")), ]

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[3],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[1],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("div0                                       div2")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-1.5,3.1)


pdf(paste0("~/Desktop/231222_draft_figures/CD8_EM_div_specific/231222_CD8_EM_div0_vs_div2_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-1.5,3.1)
dev.off()

```



```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers3)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

#remove CFSE and Ki67, as they are much more significant than others
vp <- vp[!(vp$Row.names %in% c("CFSE", "Ki67")), ]

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[4],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[1],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("div0                                       div3")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-1.5,3.1)


pdf(paste0("~/Desktop/231222_draft_figures/CD8_EM_div_specific/231222_CD8_EM_div0_vs_div3_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-1.5,3.1)
dev.off()

```


```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers4)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

#remove CFSE and Ki67, as they are much more significant than others
vp <- vp[!(vp$Row.names %in% c("CFSE", "Ki67")), ]

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[5],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = viridis(5)[1],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("div0                                       div4")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-1.5,3.1)


pdf(paste0("~/Desktop/231222_draft_figures/CD8_EM_div_specific/231222_CD8_EM_div0_vs_div4_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-1.5,3.1)
dev.off()

```


# CD8-EM divisions eTreg vs no eTreg
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("stim_0x_Treg","stim_10x_eTreg"))
table(sce_oi$condition, sce_oi$patient_id)

# remove channels that has more than one marker
sce_oi <- sce_oi[-which(rownames(sce_oi) %in% c("CD21_CD3","CD45RO_Dead")), ]

#subset to only CD8_EM
sce_oi = sce_oi[,grep("CD8_EM",sce_oi$subsets)]

# make a new coldata column with condition and division merged
sce_oi$condition_div <- paste(sce_oi$condition, sce_oi$div, sep = "_")
sce_oi$condition_div = as.factor(sce_oi$condition_div)
```

```{r}
markers <- findMarkers(sce_oi, groups = sce_oi$condition_div, assay.type = "exprs", pval.type = "some", direction = "any", full.stats=TRUE, test.type = "wilcox", block = sce_oi$patient_id)
markers0 = markers$stim_10x_eTreg_div0$stats.stim_0x_Treg_div0
markers1 = markers$stim_10x_eTreg_div1$stats.stim_0x_Treg_div1
markers2 = markers$stim_10x_eTreg_div2$stats.stim_0x_Treg_div2
markers3 = markers$stim_10x_eTreg_div3$stats.stim_0x_Treg_div3
markers4 = markers$stim_10x_eTreg_div4$stats.stim_0x_Treg_div4

markers <- findMarkers(sce_oi, groups = sce_oi$condition_div, assay.type = "exprs", pval.type = "some", direction = "any", full.stats=TRUE, test.type = "t", block = sce_oi$patient_id)
markers0_2 = markers$stim_10x_eTreg_div0$stats.stim_0x_Treg_div0
markers1_2 = markers$stim_10x_eTreg_div1$stats.stim_0x_Treg_div1
markers2_2 = markers$stim_10x_eTreg_div2$stats.stim_0x_Treg_div2
markers3_2 = markers$stim_10x_eTreg_div3$stats.stim_0x_Treg_div3
markers4_2 = markers$stim_10x_eTreg_div4$stats.stim_0x_Treg_div4

markers0 = merge(markers0, markers0_2, by = markers0, by.x = 0, by.y = 0)
markers1 = merge(markers1, markers1_2, by = markers0, by.x = 0, by.y = 0)
markers2 = merge(markers2, markers2_2, by = markers0, by.x = 0, by.y = 0)
markers3 = merge(markers3, markers3_2, by = markers0, by.x = 0, by.y = 0)
markers4 = merge(markers4, markers4_2, by = markers0, by.x = 0, by.y = 0)
```

```{r}
bluecols = brewer.pal(9,"Blues")[c(2,4,6,8,9)]
greencols = brewer.pal(9,"Greens")[c(2,4,6,8,9)]

```

```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers4)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.05,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.05,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>0.05 | abs(logFC)<log(1.05,2))
vp_name = subset(vp, abs(logFC)>log(1.05,2) & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = bluecols[5],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = greencols[5],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("no Treg                                       eTreg")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-0.5,0.5)


pdf(paste0("~/Desktop/240314_draft_figures/CD8_EM_div_specific/240314_CD8_EM_0xTreg_vs_eTreg_div4_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-0.5,0.5)
dev.off()
```


```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers3)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.05,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.05,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>0.05 | abs(logFC)<log(1.05,2))
vp_name = subset(vp, abs(logFC)>log(1.05,2) & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = bluecols[4],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = greencols[4],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("no Treg                                       eTreg")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-0.5,0.5)

pdf(paste0("~/Desktop/240314_draft_figures/CD8_EM_div_specific/240314_CD8_EM_0xTreg_vs_eTreg_div3_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-0.5,0.5)
dev.off()

```



```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers2)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.05,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.05,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>0.05 | abs(logFC)<log(1.05,2))
vp_name = subset(vp, abs(logFC)>log(1.05,2) & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = bluecols[3],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = greencols[3],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("no Treg                                       eTreg")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-0.5,0.5)

pdf(paste0("~/Desktop/240314_draft_figures/CD8_EM_div_specific/240314_CD8_EM_0xTreg_vs_eTreg_div2_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-0.5,0.5)
dev.off()

```


```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers1)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.05,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.05,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>0.05 | abs(logFC)<log(1.05,2))
vp_name = subset(vp, abs(logFC)>log(1.05,2) & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = bluecols[2],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = greencols[2],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("no Treg                                       eTreg")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-0.5,0.5)

pdf(paste0("~/Desktop/240314_draft_figures/CD8_EM_div_specific/240314_CD8_EM_0xTreg_vs_eTreg_div1_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-0.5,0.5)
dev.off()

```



```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers0)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.05,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.05,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>0.05 | abs(logFC)<log(1.05,2))
vp_name = subset(vp, abs(logFC)>log(1.05,2) & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = bluecols[1],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = greencols[1],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("no Treg                                       eTreg")+
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-0.5,0.5)

pdf(paste0("~/Desktop/240314_draft_figures/CD8_EM_div_specific/240314_CD8_EM_0xTreg_vs_eTreg_div0_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-0.5,0.5)
dev.off()

```

## eTreg aCTLA4 findmarkers
```{r}
orangecols = brewer.pal(9,"Oranges")[c(2,4,6,8,9)]
greencols = brewer.pal(9,"Greens")[c(2,4,6,8,9)]
```

```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("IgG1_10x_eTreg","aCTLA4_10x_eTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T05_D1", "T05_D2", "T06_D1", "T06_D2", "T07_D1", "T07_D2"))

# remove channels that has more than one marker, and update 240315 CTLA4
sce_oi <- sce_oi[-which(rownames(sce_oi) %in% c("CD45RO_Dead", "CTLA4")), ]

#subset to only eTregs
sce_oi = sce_oi[,grep("eTreg",sce_oi$subsets)]
sce_oi$subsets = droplevels(sce_oi$subsets)

# make a new coldata column with condition and division merged
sce_oi$condition_div <- paste(sce_oi$condition, sce_oi$div, sep = "_")
sce_oi$condition_div = as.factor(sce_oi$condition_div)

table(sce_oi$sample_id, sce_oi$subsets)
```

```{r}
markers <- findMarkers(sce_oi, groups = sce_oi$condition_div, assay.type = "exprs", pval.type = "some", direction = "any", full.stats=TRUE, test.type = "wilcox", block = sce_oi$patient_id )
markers0 = markers$aCTLA4_10x_eTreg_div0$stats.IgG1_10x_eTreg_div0
markers1 = markers$aCTLA4_10x_eTreg_div1$stats.IgG1_10x_eTreg_div1
markers2 = markers$aCTLA4_10x_eTreg_div2$stats.IgG1_10x_eTreg_div2
markers3 = markers$aCTLA4_10x_eTreg_div3$stats.IgG1_10x_eTreg_div3
markers4 = markers$aCTLA4_10x_eTreg_div4$stats.IgG1_10x_eTreg_div4

markers <- findMarkers(sce_oi, groups = sce_oi$condition_div, assay.type = "exprs", pval.type = "some", direction = "any", full.stats=TRUE, test.type = "t",block = sce_oi$patient_id)
markers0_2 = markers$aCTLA4_10x_eTreg_div0$stats.IgG1_10x_eTreg_div0
markers1_2 = markers$aCTLA4_10x_eTreg_div1$stats.IgG1_10x_eTreg_div1
markers2_2 = markers$aCTLA4_10x_eTreg_div2$stats.IgG1_10x_eTreg_div2
markers3_2 = markers$aCTLA4_10x_eTreg_div3$stats.IgG1_10x_eTreg_div3
markers4_2 = markers$aCTLA4_10x_eTreg_div4$stats.IgG1_10x_eTreg_div4

markers0 = merge(markers0, markers0_2, by = markers0, by.x = 0, by.y = 0)
markers1 = merge(markers1, markers1_2, by = markers0, by.x = 0, by.y = 0)
markers2 = merge(markers2, markers2_2, by = markers0, by.x = 0, by.y = 0)
markers3 = merge(markers3, markers3_2, by = markers0, by.x = 0, by.y = 0)
markers4 = merge(markers4, markers4_2, by = markers0, by.x = 0, by.y = 0)
```

```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers4)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.1,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.1,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.1,2))
vp_name = subset(vp, abs(logFC)>log(1.1,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))

vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = orangecols[5],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = greencols[5],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0.0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("IgG1                                       aCTLA4") +
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-1,0.7)

pdf(paste0("~/Desktop/240314_draft_figures/eTreg_div_specific/240314_eTreg_aCTLA4_vs_IgG1_div4_volcano_CTLA4_removed.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-1,0.7)
dev.off()

```

```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers3)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.1,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.1,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.1,2))
vp_name = subset(vp, abs(logFC)>log(1.1,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))

vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = orangecols[4],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = greencols[4],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0.0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("IgG1                                       aCTLA4") +
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-1,0.7)

pdf(paste0("~/Desktop/240314_draft_figures/eTreg_div_specific/240314_eTreg_aCTLA4_vs_IgG1_div3_volcano_CTLA4_removed.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-1,0.7)
dev.off()

```

```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers2)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.1,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.1,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.1,2))
vp_name = subset(vp, abs(logFC)>log(1.14,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))

vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = orangecols[3],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = greencols[3],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0.0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("IgG1                                       aCTLA4") +
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-1,0.7)

pdf(paste0("~/Desktop/240314_draft_figures/eTreg_div_specific/240314_eTreg_aCTLA4_vs_IgG1_div2_volcano_CTLA4_removed.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-1,0.7)
dev.off()

```

```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers1)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.1,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.1,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.1,2))
vp_name = subset(vp, abs(logFC)>log(1.1,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))

vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = orangecols[2],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = greencols[2],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0.0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("IgG1                                       aCTLA4") +
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-1,0.7)

pdf(paste0("~/Desktop/240314_draft_figures/eTreg_div_specific/240314_eTreg_aCTLA4_vs_IgG1_div1_volcano_CTLA4_removed.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-1,0.7)
dev.off()

```

```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers0)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.1,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.1,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.1,2))
vp_name = subset(vp, abs(logFC)>log(1.1,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))

vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = orangecols[1],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = greencols[1],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 5.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.6, "lines"),
      point.padding = unit(0.0, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("IgG1                                       aCTLA4") +
    geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 + xlim(-1,0.7)

pdf(paste0("~/Desktop/240314_draft_figures/eTreg_div_specific/240314_eTreg_aCTLA4_vs_IgG1_div0_volcano_CTLA4_removed.pdf"),width=5,height=4,paper='special') 
vp_plot4 + xlim(-1,0.7)
dev.off()

```

## 240319 - calculate proportion of eTreg/nTreg in each division.
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("stim_10x_nTreg"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
df = table(sce_oi$subsets, sce_oi$sample_id, sce_oi$condition, sce_oi$patient_id, sce_oi$div)
df = as.data.frame(df)
```

```{r}
# Calculate percentage of cells that are eTreg out of eTreg and nTreg combined for each division in Var5 and for each donor in Var4
result <- df %>%
  filter(Var1 %in% c("eTreg", "nTreg", "Tfr")) %>%
  group_by(Var5, Var4) %>%
  summarise(
    eTreg_Freq = sum(Freq[Var1 == "eTreg"]),
    nTreg_Freq = sum(Freq[Var1 == "nTreg"]),
    Tfr_Freq = sum(Freq[Var1 == "Tfr"]),
    total_Freq = eTreg_Freq + nTreg_Freq + Tfr_Freq,
    eTreg_Percentage = (eTreg_Freq / total_Freq) * 100
  )

# View the result
print(result)
```


```{r}
g = ggplot(data = result,
        aes(y = eTreg_Percentage, x = Var5)) +
        geom_boxplot(width = 0.8, guides = FALSE, outlier.size = 0, alpha = 1, color = "black") +# , fill = color_box) +
        geom_line(aes(group = Var4),alpha = 0.5) +
        geom_point(aes(fill = Var5), size = 2, alpha = 0.8, position = position_jitterdodge(), shape=21) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("% eTreg") +
    theme_bw(base_size = 14)

g
```

```{r}
pdf(paste0("~/Desktop/240319_draft_figures/240319_percentage_eTreg_in_nTreg_culture_per_division_withTfr.pdf"),width=4,height=2.5,paper='special') 
g
dev.off()
```


### selected patients
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("stim_10x_nTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T03_D1", "T03_D2", "T03_D3", "T06_D2", "T07_D2"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
df = table(sce_oi$subsets, sce_oi$sample_id, sce_oi$condition, sce_oi$patient_id, sce_oi$div)
df = as.data.frame(df)
```

```{r}
# Calculate percentage of cells that are eTreg out of eTreg and nTreg combined for each division in Var5 and for each donor in Var4
result <- df %>%
  filter(Var1 %in% c("eTreg", "nTreg", "Tfr")) %>%
  group_by(Var5, Var4) %>%
  summarise(
    eTreg_Freq = sum(Freq[Var1 == "eTreg"]),
    nTreg_Freq = sum(Freq[Var1 == "nTreg"]),
    Tfr_Freq = sum(Freq[Var1 == "Tfr"]),
    total_Freq = eTreg_Freq + nTreg_Freq + Tfr_Freq,
    eTreg_Percentage = (eTreg_Freq / total_Freq) * 100
  )

# View the result
print(result)
```


```{r}
g = ggplot(data = result,
        aes(y = eTreg_Percentage, x = Var5)) +
        geom_boxplot(width = 0.8, guides = FALSE, outlier.size = 0, alpha = 1, color = "black") +# , fill = color_box) +
        geom_line(aes(group = Var4),alpha = 0.5) +
        geom_point(aes(fill = Var5), size = 2, alpha = 0.8, position = position_jitterdodge(), shape=21) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("% eTreg") +
    theme_bw(base_size = 14)

g
```

```{r}
pdf(paste0("~/Desktop/240319_draft_figures/240319_percentage_eTreg_in_nTreg_culture_per_division_selected_donors_withTfr.pdf"),width=4,height=2.5,paper='special') 
g
dev.off()
```

```{r}
result_1 = result
```


### same but Taze condition


```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("Taze_10x_nTreg"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
df = table(sce_oi$subsets, sce_oi$sample_id, sce_oi$condition, sce_oi$patient_id, sce_oi$div)
df = as.data.frame(df)
```

```{r}
# Calculate percentage of cells that are eTreg out of eTreg and nTreg combined for each division in Var5 and for each donor in Var4
result <- df %>%
  filter(Var1 %in% c("eTreg", "nTreg", "Tfr")) %>%
  group_by(Var5, Var4) %>%
  summarise(
    eTreg_Freq = sum(Freq[Var1 == "eTreg"]),
    nTreg_Freq = sum(Freq[Var1 == "nTreg"]),
    Tfr_Freq = sum(Freq[Var1 == "Tfr"]),
    total_Freq = eTreg_Freq + nTreg_Freq + Tfr_Freq,
    eTreg_Percentage = (eTreg_Freq / total_Freq) * 100
  )

# View the result
print(result)
```


```{r}
g = ggplot(data = result,
        aes(y = eTreg_Percentage, x = Var5)) +
        geom_boxplot(width = 0.8, guides = FALSE, outlier.size = 0, alpha = 1, color = "black") +# , fill = color_box) +
        geom_line(aes(group = Var4),alpha = 0.5) +
        geom_point(aes(fill = Var5), size = 2, alpha = 0.8, position = position_jitterdodge(), shape=21) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("% eTreg") +
    theme_bw(base_size = 14)

g
```

```{r}
pdf(paste0("~/Desktop/240319_draft_figures/240319_percentage_eTreg_in_nTreg_culture_per_division_Taze_withTfr.pdf"),width=4,height=2.5,paper='special') 
g
dev.off()
```


## 240220 - overlays

```{r}

result$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result$Var5))))))

result_1$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result_1$Var5))))))

g = ggplot(data = result_1,
        aes(y = eTreg_Percentage, x = Var5)) +
        geom_boxplot(width = 0.8, guides = FALSE, outlier.size = 0, alpha = 1, color = "black") +# , fill = color_box) +
        geom_line(aes(group = Var4),alpha = 0.5) +
        geom_point(aes(fill = Var5), size = 2, alpha = 0.8, shape=21, color = "black", fill = "black") +
        #geom_smooth(aes(y = eTreg_Freq, x = Var5_numeric), fill = "black", color = "black", se = F, linewidth = 1.5) +
        geom_boxplot(data = result, width = 0.5, guides = FALSE, outlier.size = 0, alpha = 0.5, color = "red") +# , fill = color_box) +
        geom_line(data = result,aes(group = Var4),alpha = 0.5, color = "red") +
        geom_point(data = result,aes(fill = Var5), size = 2, alpha = 0.8, shape=21, color = "red", fill = "red") +
        #geom_smooth(data = result, aes(y = eTreg_Freq, x = Var5_numeric), fill = "red", color = "red", se = F, linewidth = 1.5) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("% eTreg") +
    theme_bw(base_size = 14)

g


```

```{r}
pdf(paste0("~/Desktop/240319_draft_figures/240319_percentage_eTreg_taze_vs_ctrl_withTfr.pdf"),width=3,height=2.5,paper='special') 
g
dev.off()
```


## absolute numbers instead

```{r}
# Calculate the number of eTreg cells for each division in Var5 and for each donor in Var4
result <- df %>%
  filter(Var1 == "eTreg") %>%
  group_by(Var5, Var4) %>%
  summarise(
    eTreg_Freq = sum(Freq)
  )

# View the result
print(result)
```

```{r}
result_taze = result
```


```{r}
g = ggplot(data = result,
        aes(y = eTreg_Freq, x = Var5)) +
        geom_boxplot(width = 0.8, guides = FALSE, outlier.size = 0, alpha = 1, color = "black") +# , fill = color_box) +
        geom_line(aes(group = Var4),alpha = 0.5) +
        geom_point(aes(fill = Var5), size = 2, alpha = 0.8, position = position_jitterdodge(), shape=21) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("number of eTreg") +
    theme_bw(base_size = 14)

g
```

### same, but the non-taze condition
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("stim_10x_nTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T03_D1", "T03_D2", "T03_D3", "T06_D2", "T07_D2"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
df = table(sce_oi$subsets, sce_oi$sample_id, sce_oi$condition, sce_oi$patient_id, sce_oi$div)
df = as.data.frame(df)
```


```{r}
# Calculate the number of eTreg cells for each division in Var5 and for each donor in Var4
result <- df %>%
  filter(Var1 == "eTreg") %>%
  group_by(Var5, Var4) %>%
  summarise(
    eTreg_Freq = sum(Freq)
  )

# View the result
print(result)
```


```{r}
g = ggplot(data = result,
        aes(y = eTreg_Freq, x = Var5)) +
        geom_boxplot(width = 0.8, guides = FALSE, outlier.size = 0, alpha = 1, color = "black") +# , fill = color_box) +
        geom_line(aes(group = Var4),alpha = 0.5) +
        geom_point(aes(fill = Var5), size = 2, alpha = 0.8, position = position_jitterdodge(), shape=21) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("number of eTreg") +
    theme_bw(base_size = 14)

g
```





```{r, fig.width=3, fig.height=3}
result$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result$Var5))))))

result_taze$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result_taze$Var5))))))

g = ggplot(data = result,
        aes(y = eTreg_Freq, x = Var5)) +
        geom_boxplot(width = 0.8, outlier.size = 0, alpha = 1, color = "black") +
        geom_point(fill = "black", size = 2, alpha = 0.8, shape=21) +
        geom_smooth(aes(y = eTreg_Freq, x = Var5_numeric), fill = "black", color = "black", se = F, linewidth = 1.5) +
        geom_boxplot(data = result_taze, aes(y = eTreg_Freq, x = Var5), width = 0.8, outlier.size = 0, alpha = 1, color = "red") +# , fill = color_box) +
          geom_point(data = result_taze,fill = "red", size = 2, alpha = 0.8, shape=21) +
   geom_smooth(data = result_taze, aes(y = eTreg_Freq, x = Var5_numeric), fill = "red", color = "red", se = F, linewidth = 1.5) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("number of eTreg") +
    theme_bw(base_size = 14)

g
```

## normalize data to total cells acquired per experiment

```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("Taze_10x_nTreg", "stim_10x_nTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T03_D1", "T03_D2", "T03_D3", "T06_D2", "T07_D2"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
norm_factor = colSums(table(sce_oi$condition, sce_oi$patient_id))/100000
norm_factor = rep(norm_factor,5)
norm_factor
```

```{r}
result$eTreg_Freq_norm = result$eTreg_Freq/norm_factor
result_taze$eTreg_Freq_norm = result_taze$eTreg_Freq/norm_factor

```

```{r, fig.width=3, fig.height=3}
result$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result$Var5))))))

result_taze$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result_taze$Var5))))))

g = ggplot(data = result,
        aes(y = eTreg_Freq_norm, x = Var5)) +
        geom_boxplot(width = 0.8, outlier.size = 0, alpha = 1, color = "black") +
        geom_point(fill = "black", size = 2, alpha = 0.8, shape=21) +
        geom_smooth(aes(y = eTreg_Freq_norm, x = Var5_numeric), fill = "black", color = "black", se = F, linewidth = 1.5) +
        geom_boxplot(data = result_taze, aes(y = eTreg_Freq_norm, x = Var5), width = 0.5, outlier.size = 0, alpha = 0.5, color = "red") +# , fill = color_box) +
          geom_point(data = result_taze,fill = "red", size = 2, alpha = 0.8, shape=21) +
   geom_smooth(data = result_taze, aes(y = eTreg_Freq_norm, x = Var5_numeric), fill = "red", color = "red", se = F, linewidth = 1.5) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("number of eTreg") +
    theme_bw(base_size = 14)

g
```

```{r}
pdf(paste0("~/Desktop/240220_draft_figures/240224_number_eTreg_taze_vs_ctrl.pdf"),width=3,height=2.5,paper='special') 
g
dev.off()
```

## stats
```{r}
together_table = cbind(result, result_taze)
stat.test <- aov(eTreg_Freq...3 ~ eTreg_Freq...8 * Var5...1, data = together_table) %>%
  tukey_hsd()
stat.test

tab1 = subset(together_table, Var5...1 == "div0")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div1")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div2")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div3")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div4")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

## normalized data
tab1 = subset(together_table, Var5...1 == "div0")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div1")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div2")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div3")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div4")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

```

## absolute numbers nTregs
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("Taze_10x_nTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T03_D1", "T03_D2", "T03_D3", "T06_D2", "T07_D2"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
df = table(sce_oi$subsets, sce_oi$sample_id, sce_oi$condition, sce_oi$patient_id, sce_oi$div)
df = as.data.frame(df)
```

```{r}
# Calculate the number of nTreg cells for each division in Var5 and for each donor in Var4
result <- df %>%
  filter(Var1 == "nTreg") %>%
  group_by(Var5, Var4) %>%
  summarise(
    eTreg_Freq = sum(Freq)
  )

# View the result
print(result)
```

```{r}
result_taze = result
```

```{r}
g = ggplot(data = result,
        aes(y = eTreg_Freq, x = Var5)) +
        geom_boxplot(width = 0.8, guides = FALSE, outlier.size = 0, alpha = 1, color = "black") +# , fill = color_box) +
        geom_line(aes(group = Var4),alpha = 0.5) +
        geom_point(aes(fill = Var5), size = 2, alpha = 0.8, position = position_jitterdodge(), shape=21) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("number of nTreg") +
    theme_bw(base_size = 14)

g
```

### same, but the non-taze condition
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("stim_10x_nTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T03_D1", "T03_D2", "T03_D3", "T06_D2", "T07_D2"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
df = table(sce_oi$subsets, sce_oi$sample_id, sce_oi$condition, sce_oi$patient_id, sce_oi$div)
df = as.data.frame(df)
```


```{r}
# Calculate the number of nTreg cells for each division in Var5 and for each donor in Var4
result <- df %>%
  filter(Var1 == "nTreg") %>%
  group_by(Var5, Var4) %>%
  summarise(
    eTreg_Freq = sum(Freq)
  )

# View the result
print(result)
```


```{r}
g = ggplot(data = result,
        aes(y = eTreg_Freq, x = Var5)) +
        geom_boxplot(width = 0.8, guides = FALSE, outlier.size = 0, alpha = 1, color = "black") +# , fill = color_box) +
        geom_line(aes(group = Var4),alpha = 0.5) +
        geom_point(aes(fill = Var5), size = 2, alpha = 0.8, position = position_jitterdodge(), shape=21) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("number of nTreg") +
    theme_bw(base_size = 14)

g
```





```{r, fig.width=3, fig.height=3}
result$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result$Var5))))))

result_taze$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result_taze$Var5))))))

g = ggplot(data = result,
        aes(y = eTreg_Freq, x = Var5)) +
        geom_boxplot(width = 0.8, outlier.size = 0, alpha = 1, color = "black") +
        geom_point(fill = "black", size = 2, alpha = 0.8, shape=21) +
        geom_smooth(aes(y = eTreg_Freq, x = Var5_numeric), fill = "black", color = "black", se = F, linewidth = 1.5) +
        geom_boxplot(data = result_taze, aes(y = eTreg_Freq, x = Var5), width = 0.8, outlier.size = 0, alpha = 1, color = "red") +# , fill = color_box) +
          geom_point(data = result_taze,fill = "red", size = 2, alpha = 0.8, shape=21) +
   geom_smooth(data = result_taze, aes(y = eTreg_Freq, x = Var5_numeric), fill = "red", color = "red", se = F, linewidth = 1.5) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("number of eTreg") +
    theme_bw(base_size = 14)

g
```

## normalize data to total cells acquired per experiment

```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("Taze_10x_nTreg", "stim_10x_nTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T03_D1", "T03_D2", "T03_D3", "T06_D2", "T07_D2"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
norm_factor = colSums(table(sce_oi$condition, sce_oi$patient_id))/100000
norm_factor = rep(norm_factor,5)
norm_factor
```

```{r}
result$eTreg_Freq_norm = result$eTreg_Freq/norm_factor
result_taze$eTreg_Freq_norm = result_taze$eTreg_Freq/norm_factor

```

```{r, fig.width=3, fig.height=3}
result$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result$Var5))))))

result_taze$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result_taze$Var5))))))

g = ggplot(data = result,
        aes(y = eTreg_Freq_norm, x = Var5)) +
        geom_boxplot(width = 0.8, outlier.size = 0, alpha = 1, color = "black") +
        geom_point(fill = "black", size = 2, alpha = 0.8, shape=21) +
        geom_smooth(aes(y = eTreg_Freq_norm, x = Var5_numeric), fill = "black", color = "black", se = F, linewidth = 1.5) +
        geom_boxplot(data = result_taze, aes(y = eTreg_Freq_norm, x = Var5), width = 0.5, outlier.size = 0, alpha = 0.5, color = "red") +# , fill = color_box) +
          geom_point(data = result_taze,fill = "red", size = 2, alpha = 0.8, shape=21) +
   geom_smooth(data = result_taze, aes(y = eTreg_Freq_norm, x = Var5_numeric), fill = "red", color = "red", se = F, linewidth = 1.5) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("number of nTreg") +
    theme_bw(base_size = 14)

g
```

```{r}
pdf(paste0("~/Desktop/240207_number_nTreg_taze_vs_ctrl.pdf"),width=3,height=2.5,paper='special') 
g
dev.off()
```

## stats
```{r}
together_table = cbind(result, result_taze)

stat.test <- aov(eTreg_Freq...3 ~ eTreg_Freq...8 * Var5...1, data = together_table) %>%
  tukey_hsd()
stat.test

tab1 = subset(together_table, Var5...1 == "div0")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div1")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div2")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div3")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div4")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

## normalized data
tab1 = subset(together_table, Var5...1 == "div0")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div1")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div2")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div3")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div4")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

```

## absolute numbers eTregs in eTreg culture
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("Taze_10x_eTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T03_D1", "T03_D2", "T03_D3", "T06_D2", "T07_D2"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
df = table(sce_oi$subsets, sce_oi$sample_id, sce_oi$condition, sce_oi$patient_id, sce_oi$div)
df = as.data.frame(df)
```

```{r}
# Calculate the number of eTreg cells for each division in Var5 and for each donor in Var4
result <- df %>%
  filter(Var1 == "nTreg") %>%
  group_by(Var5, Var4) %>%
  summarise(
    eTreg_Freq = sum(Freq)
  )

# View the result
print(result)
```

```{r}
result_taze = result
```

```{r}
g = ggplot(data = result,
        aes(y = eTreg_Freq, x = Var5)) +
        geom_boxplot(width = 0.8, guides = FALSE, outlier.size = 0, alpha = 1, color = "black") +# , fill = color_box) +
        geom_line(aes(group = Var4),alpha = 0.5) +
        geom_point(aes(fill = Var5), size = 2, alpha = 0.8, position = position_jitterdodge(), shape=21) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("number of eTreg") +
    theme_bw(base_size = 14)

g
```

### same, but the non-taze condition
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("stim_10x_eTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T03_D1", "T03_D2", "T03_D3", "T06_D2", "T07_D2"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
df = table(sce_oi$subsets, sce_oi$sample_id, sce_oi$condition, sce_oi$patient_id, sce_oi$div)
df = as.data.frame(df)
```

```{r}
# Calculate the number of nTreg cells for each division in Var5 and for each donor in Var4
result <- df %>%
  filter(Var1 == "eTreg") %>%
  group_by(Var5, Var4) %>%
  summarise(
    eTreg_Freq = sum(Freq)
  )

# View the result
print(result)
```


```{r}
g = ggplot(data = result,
        aes(y = eTreg_Freq, x = Var5)) +
        geom_boxplot(width = 0.8, guides = FALSE, outlier.size = 0, alpha = 1, color = "black") +# , fill = color_box) +
        geom_line(aes(group = Var4),alpha = 0.5) +
        geom_point(aes(fill = Var5), size = 2, alpha = 0.8, position = position_jitterdodge(), shape=21) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("number of eTreg") +
    theme_bw(base_size = 14)

g
```

```{r, fig.width=3, fig.height=3}
result$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result$Var5))))))

result_taze$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result_taze$Var5))))))

g = ggplot(data = result,
        aes(y = eTreg_Freq, x = Var5)) +
        geom_boxplot(width = 0.8, outlier.size = 0, alpha = 1, color = "black") +
        geom_point(fill = "black", size = 2, alpha = 0.8, shape=21) +
        geom_smooth(aes(y = eTreg_Freq, x = Var5_numeric), fill = "black", color = "black", se = F, linewidth = 1.5) +
        geom_boxplot(data = result_taze, aes(y = eTreg_Freq, x = Var5), width = 0.8, outlier.size = 0, alpha = 1, color = "red") +# , fill = color_box) +
          geom_point(data = result_taze,fill = "red", size = 2, alpha = 0.8, shape=21) +
   geom_smooth(data = result_taze, aes(y = eTreg_Freq, x = Var5_numeric), fill = "red", color = "red", se = F, linewidth = 1.5) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("number of eTreg") +
    theme_bw(base_size = 14)

g
```

## normalize data to total cells acquired per experiment
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("Taze_10x_eTreg", "stim_10x_eTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T03_D1", "T03_D2", "T03_D3", "T06_D2", "T07_D2"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
norm_factor = colSums(table(sce_oi$condition, sce_oi$patient_id))/100000
norm_factor = rep(norm_factor,5)
norm_factor
```

```{r}
result$eTreg_Freq_norm = result$eTreg_Freq/norm_factor
result_taze$eTreg_Freq_norm = result_taze$eTreg_Freq/norm_factor

```

```{r, fig.width=3, fig.height=3}
result$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result$Var5))))))

result_taze$Var5_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", result_taze$Var5))))))

g = ggplot(data = result,
        aes(y = eTreg_Freq_norm, x = Var5)) +
        geom_boxplot(width = 0.8, outlier.size = 0, alpha = 1, color = "black") +
        geom_point(fill = "black", size = 2, alpha = 0.8, shape=21) +
        geom_smooth(aes(y = eTreg_Freq_norm, x = Var5_numeric), fill = "black", color = "black", se = F, linewidth = 1.5) +
        geom_boxplot(data = result_taze, aes(y = eTreg_Freq_norm, x = Var5), width = 0.8, outlier.size = 0, alpha = 1, color = "red") +# , fill = color_box) +
          geom_point(data = result_taze,fill = "red", size = 2, alpha = 0.8, shape=21) +
   geom_smooth(data = result_taze, aes(y = eTreg_Freq_norm, x = Var5_numeric), fill = "red", color = "red", se = F, linewidth = 1.5) +
        theme_bw() +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
    xlab("") +
    ylab("number of eTreg") +
    theme_bw(base_size = 14)

g
```

```{r}
pdf(paste0("~/Desktop/240207_number_eTreg_taze_vs_ctrl_eTreg_culture.pdf"),width=3,height=2.5,paper='special') 
g
dev.off()
```

## stats
```{r}
together_table = cbind(result, result_taze)

stat.test <- aov(eTreg_Freq...3 ~ eTreg_Freq...8 * Var5...1, data = together_table) %>%
  tukey_hsd()
stat.test

tab1 = subset(together_table, Var5...1 == "div0")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div1")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div2")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div3")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div4")
t.test(tab1$eTreg_Freq...3, tab1$eTreg_Freq...8, paired = T, alternative = "two.sided")



## normalized data
tab1 = subset(together_table, Var5...1 == "div0")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div1")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div2")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div3")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

tab1 = subset(together_table, Var5...1 == "div4")
t.test(tab1$eTreg_Freq_norm...5, tab1$eTreg_Freq_norm...10, paired = T, alternative = "two.sided")

```



## compare div0 to div0 etc. for only Taze, original versus nTreg-derived eTreg
```{r}
#sce_oi = filterSCE(sce_recombined, condition %in% c("Taze_10x_nTreg", "Taze_10x_eTreg", "stim_10x_nTreg", "stim_10x_eTreg"))
sce_oi = filterSCE(sce_recombined, condition %in% c("Taze_10x_eTreg", "Taze_10x_nTreg"))
table(sce_oi$condition, sce_oi$patient_id)
sce_oi = filterSCE(sce_oi, patient_id %in% c("T03_D1", "T03_D2", "T03_D3", "T06_D2", "T07_D2"))

# remove channels that has more than one marker
sce_oi <- sce_oi[-which(rownames(sce_oi) %in% c("CD21_CD3","CD45RO_Dead")), ]

#subset to only eTregs
sce_oi = sce_oi[,grep("eTreg",sce_oi$subsets)]
table(sce_oi$condition, sce_oi$patient_id)
```

## make a new coldata column with condition and division merged
```{r}
sce_oi$condition_div <- paste(sce_oi$condition, sce_oi$div, sep = "_")
```

```{r}
markers <- findMarkers(sce_oi, groups = sce_oi$condition_div, assay.type = "exprs", pval.type = "some", direction = "any", full.stats=TRUE, test.type = "wilcox", block = sce_oi$patient_id)
markers1 = markers$Taze_10x_eTreg_div0$stats.Taze_10x_nTreg_div0
markers2 = markers$Taze_10x_eTreg_div1$stats.Taze_10x_nTreg_div1
markers3 = markers$Taze_10x_eTreg_div2$stats.Taze_10x_nTreg_div2
markers4 = markers$Taze_10x_eTreg_div3$stats.Taze_10x_nTreg_div3
markers5 = markers$Taze_10x_eTreg_div4$stats.Taze_10x_nTreg_div4


markers <- findMarkers(sce_oi, groups = sce_oi$condition_div, assay.type = "exprs", pval.type = "some", direction = "any", full.stats=TRUE, test.type = "t", block = sce_oi$patient_id)
markers1_2 = markers$Taze_10x_eTreg_div0$stats.Taze_10x_nTreg_div0
markers2_2 = markers$Taze_10x_eTreg_div1$stats.Taze_10x_nTreg_div1
markers3_2 = markers$Taze_10x_eTreg_div2$stats.Taze_10x_nTreg_div2
markers4_2 = markers$Taze_10x_eTreg_div3$stats.Taze_10x_nTreg_div3
markers5_2 = markers$Taze_10x_eTreg_div4$stats.Taze_10x_nTreg_div4


markers1 = merge(markers1, markers1_2, by = markers1, by.x = 0, by.y = 0)
markers2 = merge(markers2, markers2_2, by = markers2, by.x = 0, by.y = 0)
markers3 = merge(markers3, markers3_2, by = markers3, by.x = 0, by.y = 0)
markers4 = merge(markers4, markers4_2, by = markers4, by.x = 0, by.y = 0)
markers5 = merge(markers5, markers5_2, by = markers4, by.x = 0, by.y = 0)

```

```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers1)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

#remove CFSE and Ki67, as they are much more significant than others
vp <- vp[!(vp$Row.names %in% c("CFSE", "Ki67")), ]

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Blues")[2],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Reds")[2],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 4.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("nTreg-derived eTreg                div0                 original eTreg") +     geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 = vp_plot4 + xlim(-2.2, 2.3)
vp_plot4


pdf(paste0("~/Desktop/240220_draft_figures/Taze_div_specific/240220_eTreg_from_eTreg_div0_Taze_vs_eTreg_from_nTreg_div0_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 
dev.off()

```

```{r}
sce_check = filterSCE(sce_oi, div =="div0")

plotPbExprs(sce_check, k = "som100", features = c("CCR7", "H3K27me3", "CD39"),  
    group_by = "condition", color_by = "condition", ncol = 8, shape_by = "patient_id") + 
  theme_bw(base_size = 18) + 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) +         
  scale_color_manual(values = rep("black",4)) +
  scale_shape_manual(values=c(21,22,23,24,25,12,10,7))
```

```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers2)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

#remove CFSE and Ki67, as they are much more significant than others
vp <- vp[!(vp$Row.names %in% c("CFSE", "Ki67")), ]

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Blues")[4],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Reds")[4],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 4.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("nTreg-derived eTreg                div1                 original eTreg") +     geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 = vp_plot4 + xlim(-2.2, 2.3)
vp_plot4

pdf(paste0("~/Desktop/240220_draft_figures/Taze_div_specific/240220_eTreg_from_eTreg_div1_Taze_vs_eTreg_from_nTreg_div1_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 
dev.off()

```



```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers3)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

#remove CFSE and Ki67, as they are much more significant than others
vp <- vp[!(vp$Row.names %in% c("CFSE", "Ki67")), ]

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Blues")[6],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Reds")[6],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 4.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("nTreg-derived eTreg                div2                 original eTreg") +     geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 = vp_plot4 + xlim(-2.2, 2.3)
vp_plot4


pdf(paste0("~/Desktop/240220_draft_figures/Taze_div_specific/240220_eTreg_from_eTreg_div2_Taze_vs_eTreg_from_nTreg_div2_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 
dev.off()

```


```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers4)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

#remove CFSE and Ki67, as they are much more significant than others
vp <- vp[!(vp$Row.names %in% c("CFSE", "Ki67")), ]

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Blues")[8],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Reds")[8],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 4.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("nTreg-derived eTreg                div3                 original eTreg") +     geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 = vp_plot4 + xlim(-2.2, 2.3)
vp_plot4


pdf(paste0("~/Desktop/240220_draft_figures/Taze_div_specific/240220_eTreg_from_eTreg_div3_Taze_vs_eTreg_from_nTreg_div3_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 
dev.off()

```



```{r, fig.height=5,fig.width=8}
#### Plot a Volcano plot of findmarkers results
vp = as.data.frame(markers5)

# zero expression may result in NAs which we remove
vp = na.omit(vp)

#remove CFSE and Ki67, as they are much more significant than others
vp <- vp[!(vp$Row.names %in% c("CFSE", "Ki67")), ]

# the name will be a combination of the cell type and the marker
vp$name =  vp$Row.names

# here the code is similar to DA plots
vp_sign_up = subset(vp, logFC>log(1.2,2) & log.FDR.x<(-1.30) | logFC>0.33 & log.FDR.x<(-1.30))
vp_sign_dn = subset(vp, logFC<(-log(1.2,2)) & log.FDR.x<(-1.30) | logFC<(-0.33) & log.FDR.x<(-1.30))
vp_non_sign = subset(vp, log.FDR.x>(-1.30) | abs(logFC)<log(1.2,2))
vp_name = subset(vp, abs(logFC)>log(1.2,2) & log.FDR.x<(-1.30) | abs(logFC)>0.33 & log.FDR.x<(-1.30))


vp_plot4= ggplot() +
  geom_point(
      data = vp_non_sign,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.2,
      fill = "grey",
      color = "black",
      pch = 21
    ) +
  geom_point(
      data = vp_sign_up,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Blues")[9],
      color = "black",
      pch = 21
    ) +
    geom_point(
      data = vp_sign_dn,
      aes(x = logFC, y = -(log.FDR.x), size = abs(logFC)),
      alpha = 0.8,
      fill = brewer.pal(9,"Reds")[9],
      color = "black",
      pch = 21
    ) +
  geom_text_repel(
      data = vp_name,
      aes(x = logFC, -(log.FDR.x), label=name),
      size = 4.5,
      min.segment.length = 0, #use to always put a line
      box.padding = unit(0.35, "lines"),
      point.padding = unit(0.3, "lines"),
      max.overlaps = 100
        ) +
    theme_bw(base_size = 14) +
    labs(size="logFC", x = "logFC", y = "-log10(FDR)") +
    guides(size=guide_legend(override.aes=list(fill="white"))) +
    ggtitle("nTreg-derived eTreg                div4                 original eTreg") +     geom_vline(xintercept=0, linetype='dotted', col = 'black')

vp_plot4 = vp_plot4 + xlim(-2.2, 2.3)
vp_plot4


pdf(paste0("~/Desktop/240220_draft_figures/Taze_div_specific/240220_eTreg_from_eTreg_div4_Taze_vs_eTreg_from_nTreg_div4_volcano.pdf"),width=5,height=4,paper='special') 
vp_plot4 
dev.off()

```


## 240319 make CTLA4 effect heatmap as in Fig 1

```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("IgG1_10x_eTreg","aCTLA4_10x_eTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T05_D1", "T05_D2", "T06_D1", "T06_D2", "T07_D1", "T07_D2")) #donors used for current diffcyt figure
table(sce_oi$condition, sce_oi$patient_id)
sce_sub = sce_oi
```


```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div0") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  
    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id



## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("IgG1", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("aCTLA4", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div0"

result_table_delta_mean_all = result_table_delta_mean

# add to total dataset
result_table_delta_mean_all$div0 = result_table_delta_mean
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div1") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id



## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("IgG1", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("aCTLA4", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div1"

# add to total dataset
result_table_delta_mean_all$div1 = result_table_delta_mean
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div2") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id

## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("IgG1", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("aCTLA4", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div2"

# add to total dataset
result_table_delta_mean_all$div2 = result_table_delta_mean
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div3") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id

## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("IgG1", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("aCTLA4", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div3"

# add to total dataset
result_table_delta_mean_all$div3 = result_table_delta_mean
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div4") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id

## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("IgG1", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("aCTLA4", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div4"

# add to total dataset
result_table_delta_mean_all$div4 = result_table_delta_mean
```


```{r}
test = result_table_delta_mean_all[c(1:19),]
 
paletteLength <- 100
myColor <- colorRampPalette(c("darkred", "white", "darkblue"))(paletteLength)


# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(min(test), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(test)/paletteLength, max(test), length.out=floor(paletteLength/2)))

ph = pheatmap(test, 
         border_color = "black", 
         cluster_rows = T,
         cluster_cols = F,
         color = myColor,
         breaks=myBreaks
         )

row_order <- ph$tree_row$order
```

```{r}
pdf(paste0("~/Desktop/240319_draft_figures/240319_Fig1style_heat_aCTLA4_diff.pdf"),width=3,height=3,paper='special') 
ph
dev.off()
```

## 240327 - make heatmap (one line) of percentage divided to add to above heatmap
```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div0") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  
    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id

## split into the two conditions
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("IgG1", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("aCTLA4", rownames(result_table_only_numbers)), ]

# find mean values
result_table_only_numbers_1_mean =colMeans(as.matrix(result_table_only_numbers_1), na.rm = TRUE)
result_table_only_numbers_1_mean = as.data.frame(result_table_only_numbers_1_mean)

result_table_only_numbers_2_mean =colMeans(as.matrix(result_table_only_numbers_2), na.rm = TRUE)
result_table_only_numbers_2_mean = as.data.frame(result_table_only_numbers_2_mean)

# label the dataset
colnames(result_table_only_numbers_1_mean) = "div1" # this is "IgG1", but label as div1, to make heatmap same size
colnames(result_table_only_numbers_2_mean) = "div4" # this is "aCTLA4", but label as div4, to make heatmap same size

# combine
result_table_percDivided_mean = result_table_only_numbers_1_mean
result_table_percDivided_mean$div4 = result_table_only_numbers_2_mean

## find delta values
result_table_delta = result_table_only_numbers_2 - result_table_only_numbers_1

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)
colnames(result_table_delta_mean) = "div1"
rownames(result_table_delta_mean) = colnames(result_table_delta)
result_table_delta_mean$div4 = result_table_delta_mean
```

```{r}
test = result_table_percDivided_mean[c(1:19),]
test <- test[row_order, ]
 
paletteLength <- 100
myColor <- magma(paletteLength)

# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(min(test), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(test)/paletteLength, max(test), length.out=floor(paletteLength/2)))

ph = pheatmap(test, 
         border_color = "black", 
         cluster_rows = F,
         cluster_cols = F,
         color = myColor
         )
```

```{r}
pdf(paste0("~/Desktop/240327_draft_figures/240327_Fig1style_heat_aCTLA4_percDiv.pdf"),width=1.78,height=3,paper='special') 
ph
dev.off()
```


```{r}
test = result_table_delta_mean[c(1:19),]
test <- test[row_order, ]

paletteLength <- 100
myColor <- colorRampPalette(c("darkgreen", "white", "gold"))(paletteLength)


# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(min(test), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(test)/paletteLength, max(test), length.out=floor(paletteLength/2)))

ph = pheatmap(test, 
         border_color = "black", 
         cluster_rows = F,
         cluster_cols = F,
         color = myColor,
         breaks=myBreaks
         )
```

```{r}
pdf(paste0("~/Desktop/240327_draft_figures/240329_Fig1style_heat_aCTLA4_percDiv_difference.pdf"),width=1.87,height=3,paper='special') 
ph
dev.off()
```

## 240327 - make heatmap (one line) of division index to add to above heatmap
https://docs.flowjo.com/flowjo/experiment-based-platforms/proliferation/
Division Index is the average number of cell divisions that a cell in the original population has undergone. This is an average even for cells which never divided (i.e., includes the undivided peak).
As an example of how Proliferation Index and Division Index would be calculated, consider the following:

G0 = 15888

G1 = 32922

G2 = 13647

G3 = 897

Total Number of Cells: 15888 + 32922 +13647 +897 = 63354

Total Number of Divided Cells: 32922 +13647 +897 = 47466


-----need these two----
The number of cells at start of culture: 15888 + (32922/2) + (13647/4) + (897/8) = 35872.875

The total number of divisions: (32922/2)*1 + (13647/4)*2 + (897/8)*3 = 23620.875
-----need these two----


The number of cells that went into division: 35872.875 – 15888 = 19984.875

Division Index: 23620.875 / 35872.875 = 0.66

Proliferation Index: 23620.875 / 19984.875 = 1.18

Division Index: Total Number of Divisions / The number of cells at start of culture

Proliferation Index: Total Number of Divisions / Cells that went into division

So first I need the number of cells in each division. I should be able to get that simply from a table of my "div"

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    count <- sum(subset_data$div == "div0")
} else {
  count = NA
}
  
    # Store the result in the result_table
    result_table[i, j] <- count
  }
}

result_table_div0 = result_table


result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    count <- sum(subset_data$div == "div1")
} else {
  count = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- count
  }
}

result_table_div1 = result_table



result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    count <- sum(subset_data$div == "div2")
} else {
  count = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- count
  }
}

result_table_div2 = result_table

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    count <- sum(subset_data$div == "div3")
} else {
  count = NA
}
  
    # Store the result in the result_table
    result_table[i, j] <- count
  }
}

result_table_div3 = result_table


result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    count <- sum(subset_data$div == "div4")
} else {
  count = NA
}
  
    # Store the result in the result_table
    result_table[i, j] <- count
  }
}

result_table_div4 = result_table


#The number of cells at start of culture: 
result_table_starting_cells = result_table_div0 + (result_table_div1/2) + (result_table_div2/4) + (result_table_div3/8) + (result_table_div4/16)

#The total number of divisions: 
result_table_tot_divisions = (result_table_div1/2)*1 + (result_table_div2/4)*2 + (result_table_div3/8)*3 + (result_table_div4/16)*4

# Division Index: Total Number of Divisions / The number of cells at start of culture
divIndex = result_table_tot_divisions/result_table_starting_cells

# rename and use previous code
result_table = divIndex

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id

## split into the two conditions
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("IgG1", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("aCTLA4", rownames(result_table_only_numbers)), ]

# find mean values
result_table_only_numbers_1_mean =colMeans(as.matrix(result_table_only_numbers_1), na.rm = TRUE)
result_table_only_numbers_1_mean = as.data.frame(result_table_only_numbers_1_mean)

result_table_only_numbers_2_mean =colMeans(as.matrix(result_table_only_numbers_2), na.rm = TRUE)
result_table_only_numbers_2_mean = as.data.frame(result_table_only_numbers_2_mean)

# label the dataset
colnames(result_table_only_numbers_1_mean) = "div1" # this is "IgG1", but label as div1, to make heatmap same size
colnames(result_table_only_numbers_2_mean) = "div4" # this is "aCTLA4", but label as div4, to make heatmap same size

# combine
result_table_divIndex_mean = result_table_only_numbers_1_mean
result_table_divIndex_mean$div4 = result_table_only_numbers_2_mean

## find delta values
result_table_delta = result_table_only_numbers_2 - result_table_only_numbers_1

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)
colnames(result_table_delta_mean) = "div1"
rownames(result_table_delta_mean) = colnames(result_table_delta)
result_table_delta_mean$div4 = result_table_delta_mean
```

```{r}
test = result_table_divIndex_mean[c(1:19),]
test <- test[row_order, ]
 
paletteLength <- 100
myColor <- viridis(paletteLength)

# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(min(test), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(test)/paletteLength, max(test), length.out=floor(paletteLength/2)))

ph = pheatmap(test, 
         border_color = "black", 
         cluster_rows = F,
         cluster_cols = F,
         color = myColor
         )
```

```{r}
pdf(paste0("~/Desktop/240327_draft_figures/240327_Fig1style_heat_aCTLA4_divIndex.pdf"),width=1.8,height=3,paper='special') 
ph
dev.off()
```


```{r}
result_table_delta_mean_Fig1_divIndex = result_table_delta_mean # backup
test = result_table_delta_mean[c(1:19),]
test <- test[row_order, ]

paletteLength <- 100
myColor <- colorRampPalette(c("purple", "white", "orange"))(paletteLength)

# Select only numeric columns from 'test'
numeric_test <- test[, sapply(test, is.numeric)]

# Determine the maximum absolute value in the numeric data
max_abs <- max(abs(numeric_test))

# manually adjust
max_abs = 0.5

# Generate breaks symmetrically around zero
myBreaks <- c(seq(-max_abs, 0, length.out = ceiling(paletteLength/2) + 1),
              seq(max_abs/paletteLength, max_abs, length.out = floor(paletteLength/2)))

ph = pheatmap(test, 
         border_color = "black", 
         cluster_rows = F,
         cluster_cols = F,
         color = myColor,
         breaks=myBreaks
         )
```

```{r}
pdf(paste0("~/Desktop/240402_draft_figures/240402_Fig1style_heat_aCTLA4_divIndex_difference.pdf"),width=1.9,height=3,paper='special') 
ph
dev.off()
```


## 240401 make Tazemetostat effect heatmap as in Fig 1 (with nTreg)
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("Taze_10x_nTreg", "stim_10x_nTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T03_D1", "T03_D2", "T03_D3", "T06_D2", "T07_D2")) #donors used for current diffcyt figure
table(sce_oi$condition, sce_oi$patient_id)
sce_sub = sce_oi
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div0") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  
    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id

## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("stim", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("Taze", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div0"

result_table_delta_mean_all = result_table_delta_mean

# add to total dataset
result_table_delta_mean_all$div0 = result_table_delta_mean
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div1") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id

## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("stim", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("Taze", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div1"

# add to total dataset
result_table_delta_mean_all$div1 = result_table_delta_mean
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div2") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  
    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id

## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("stim", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("Taze", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div2"

# add to total dataset
result_table_delta_mean_all$div2 = result_table_delta_mean
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div3") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  
    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id

## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("stim", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("Taze", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div3"

# add to total dataset
result_table_delta_mean_all$div3 = result_table_delta_mean
```

```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div4") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  

    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id



## find delta values
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("stim", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("Taze", rownames(result_table_only_numbers)), ]
result_table_delta = result_table_only_numbers_1 - result_table_only_numbers_2

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)

# label the dataset
colnames(result_table_delta_mean) = "div4"

# add to total dataset
result_table_delta_mean_all$div4 = result_table_delta_mean
```

```{r}
test = result_table_delta_mean_all[c(1:20),]
 
paletteLength <- 100
myColor <- colorRampPalette(c("darkred", "white", "darkblue"))(paletteLength)

# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(min(test), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(test)/paletteLength, max(test), length.out=floor(paletteLength/2)))

ph = pheatmap(test, 
         border_color = "black", 
         cluster_rows = T,
         cluster_cols = F,
         color = myColor,
         breaks=myBreaks
         )

row_order <- ph$tree_row$order
```

```{r}
pdf(paste0("~/Desktop/240401_draft_figures/240401_Fig1style_heat_Taze_diff.pdf"),width=3,height=3,paper='special') 
ph
dev.off()
```


## 240327 - make heatmap (one line) of percentage divided to add to above heatmap
```{r}
sample_id_list = levels(sce_sub$sample_id)
subset_list = levels(sce_sub$subsets)

result_table <- matrix(NA, nrow = length(unique(sce_sub$sample_id)), ncol = length(unique(sce_sub$subsets)))
rownames(result_table) <- sample_id_list
colnames(result_table) <- subset_list

# Loop through each combination of sample_id and subsets
for (i in 1:length(sample_id_list)) {
  for (j in 1:length(subset_list)) {
    # Subset the data based on sample_id and subsets
    sid = sample_id_list[i]
    subs = subset_list[j]
    
    
    if (table(sce_sub$sample_id == sid & sce_sub$subsets == subs)[2] >5 & length(table(sce_sub$sample_id == sid & sce_sub$subsets == subs)) != 1){
    subset_data <- filterSCE(sce_sub, sample_id == sid & subsets == subs)
    percentage <- 100-(sum(subset_data$div == "div0") / length(subset_data$div) * 100)
} else {
  percentage = NA
}
  
    # Store the result in the result_table
    result_table[i, j] <- percentage
  }
}

result_table_backup = result_table
result_table = result_table_backup

## add metadata
result_table = as.data.frame(result_table)
result_table = merge(result_table, ei(sce_sub), by = result_table, by.x = 0, by.y = 1)
result_table = result_table[3:length(result_table)-1]
result_table$sample_id = paste0(result_table$condition, "_", result_table$patient_id)

# select numbers only
result_table_only_numbers = result_table[,c(1:21)]
rownames(result_table_only_numbers) = result_table$sample_id

## split into the two conditions
result_table_only_numbers = result_table_only_numbers[order(rownames(result_table_only_numbers)), ]
result_table_only_numbers_1 = result_table_only_numbers[grepl("stim", rownames(result_table_only_numbers)), ]
result_table_only_numbers_2 = result_table_only_numbers[grepl("Taze", rownames(result_table_only_numbers)), ]

# find mean values
result_table_only_numbers_1_mean =colMeans(as.matrix(result_table_only_numbers_1), na.rm = TRUE)
result_table_only_numbers_1_mean = as.data.frame(result_table_only_numbers_1_mean)

result_table_only_numbers_2_mean =colMeans(as.matrix(result_table_only_numbers_2), na.rm = TRUE)
result_table_only_numbers_2_mean = as.data.frame(result_table_only_numbers_2_mean)

# label the dataset
colnames(result_table_only_numbers_1_mean) = "div1" # this is "stim", but label as div1, to make heatmap same size
colnames(result_table_only_numbers_2_mean) = "div4" # this is "Taze", but label as div4, to make heatmap same size

# combine
result_table_percDivided_mean = result_table_only_numbers_1_mean
result_table_percDivided_mean$div4 = result_table_only_numbers_2_mean

## find delta values
result_table_delta = result_table_only_numbers_2 - result_table_only_numbers_1

# find mean of delta
result_table_delta_mean =colMeans(as.matrix(result_table_delta), na.rm = TRUE)
result_table_delta_mean = as.data.frame(result_table_delta_mean)
colnames(result_table_delta_mean) = "div1"
rownames(result_table_delta_mean) = colnames(result_table_delta)
result_table_delta_mean$div4 = result_table_delta_mean
```

```{r}
test = result_table_percDivided_mean[c(1:20),]
test <- test[row_order, ]
 
paletteLength <- 100
myColor <- magma(paletteLength)

# use floor and ceiling to deal with even/odd length pallettelengths
myBreaks <- c(seq(min(test), 0, length.out=ceiling(paletteLength/2) + 1), 
              seq(max(test)/paletteLength, max(test), length.out=floor(paletteLength/2)))

ph = pheatmap(test, 
         border_color = "black", 
         cluster_rows = F,
         cluster_cols = F,
         color = myColor#,
         #breaks=myBreaks
         )
```

```{r}
pdf(paste0("~/Desktop/240401_draft_figures/240401_Fig1style_heat_Taze_percDiv.pdf"),width=1.78,height=3,paper='special') 
ph
dev.off()
```


```{r}
test = result_table_delta_mean[c(1:20),]
test <- test[row_order, ]

paletteLength <- 100
myColor <- colorRampPalette(c("darkgreen", "white", "gold"))(paletteLength)

# Select only numeric columns from 'test'
numeric_test <- test[, sapply(test, is.numeric)]

# Determine the maximum absolute value in the numeric data
max_abs <- max(abs(numeric_test))

# manually adjust
#max_abs = 0.5

# Generate breaks symmetrically around zero
myBreaks <- c(seq(-max_abs, 0, length.out = ceiling(paletteLength/2) + 1),
              seq(max_abs/paletteLength, max_abs, length.out = floor(paletteLength/2)))

ph = pheatmap(test, 
         border_color = "black", 
         cluster_rows = F,
         cluster_cols = F,
         color = myColor,
         breaks=myBreaks
         )
```

```{r}
pdf(paste0("~/Desktop/240402_draft_figures/240403_Fig1style_heat_Taze_percDiv_difference.pdf"),width=1.87,height=3,paper='special') 
ph
dev.off()
```

## 240404 - plot histograms of H3K27me3 per division for eTregs from different cultures
```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("Taze_10x_nTreg", "stim_10x_nTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T03_D1", "T03_D2", "T03_D3", "T06_D2", "T07_D2")) #donors used for current diffcyt figure
sce_oi = filterSCE(sce_oi, subsets %in% c("eTreg"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
sce_oi2 = filterSCE(sce_oi, subsets %in% c("eTreg"))

sce_sub = filterSCE(sce_oi2, div %in% c("div0"))
p0 = plotPbExprs(sce_sub, features = "H3K27me3")
p0$data$div = "div0"

sce_sub = filterSCE(sce_oi2, div %in% c("div1"))
p1 = plotPbExprs(sce_sub, features = "H3K27me3")
p1$data$div = "div1"

sce_sub = filterSCE(sce_oi2, div %in% c("div2"))
p2 = plotPbExprs(sce_sub, features = "H3K27me3")
p2$data$div = "div2"

sce_sub = filterSCE(sce_oi2, div %in% c("div3"))
p3 = plotPbExprs(sce_sub, features = "H3K27me3")
p3$data$div = "div3"

sce_sub = filterSCE(sce_oi2, div %in% c("div4"))
p4 = plotPbExprs(sce_sub, features = "H3K27me3")
p4$data$div = "div4"

p_all = rbind(p0$data, p1$data, p2$data, p3$data, p4$data)
```

```{r}
sce_oi = filterSCE(sce_recombined, condition %in% c("Taze_10x_eTreg", "stim_10x_eTreg"))
sce_oi = filterSCE(sce_oi, patient_id %in% c("T03_D1", "T03_D2", "T03_D3", "T06_D2", "T07_D2")) #donors used for current diffcyt figure
sce_oi = filterSCE(sce_oi, subsets %in% c("eTreg"))
table(sce_oi$condition, sce_oi$patient_id)
```

```{r}
sce_oi2 = filterSCE(sce_oi, subsets %in% c("eTreg"))

sce_sub = filterSCE(sce_oi2, div %in% c("div0"))
p0 = plotPbExprs(sce_sub, features = "H3K27me3")
p0$data$div = "div0"

sce_sub = filterSCE(sce_oi2, div %in% c("div1"))
p1 = plotPbExprs(sce_sub, features = "H3K27me3")
p1$data$div = "div1"

sce_sub = filterSCE(sce_oi2, div %in% c("div2"))
p2 = plotPbExprs(sce_sub, features = "H3K27me3")
p2$data$div = "div2"

sce_sub = filterSCE(sce_oi2, div %in% c("div3"))
p3 = plotPbExprs(sce_sub, features = "H3K27me3")
p3$data$div = "div3"

sce_sub = filterSCE(sce_oi2, div %in% c("div4"))
p4 = plotPbExprs(sce_sub, features = "H3K27me3")
p4$data$div = "div4"

p_all = rbind(p_all, p0$data, p1$data, p2$data, p3$data, p4$data)

p_all = melt(p_all)
```

```{r}
col_order = c(brewer.pal(9,"Reds")[c(4,8)], brewer.pal(9,"Blues")[c(4,8)])

p_all$div_numeric <- as.numeric(
  gsub("div4", "5", 
  gsub("div3", "4", 
  gsub("div2", "3", 
  gsub("div1", "2", 
  gsub("div0", "1", p_all$div))))))

data_sub_1 = subset(p_all, condition == "stim_10x_nTreg")

g = ggplot(data = p_all,
        aes(y = value, x = div, fill = condition)) +
        geom_boxplot(width = 0.7, outlier.size = 0, alpha = 1, position = position_dodge(width = 0.8)) +# , fill = color_box) +
        geom_point(size = 1, alpha = 0.6,shape=21, position = position_dodge(width = 0.8)) +
        stat_smooth(aes(y = value, x = div_numeric, fill = condition, color = condition), geom='line',  se = F, linewidth = 1.5, alpha = 0.6) +
        theme_bw() +
        facet_wrap(p_all$subsets) +
        labs(y= paste("H3K27me3"), x = "") +
        theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust = 1)) +
        scale_fill_manual(values = col_order) +
        scale_color_manual(values = col_order)
g
```
```{r}
pdf(paste0("~/Desktop/240405_draft_figures/240405_H3K27me3_boxplot_eTreg_Taze_trendline.pdf"),width=5,height=2.5,paper='special') 
g
dev.off()
```